"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4691],{9648:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Learn/Technologies/fraud-proofs-on-bitcoin","title":"Fraud Proofs on Bitcoin","description":"Background","source":"@site/docs/Learn/Technologies/fraud-proofs-on-bitcoin.md","sourceDirName":"Learn/Technologies","slug":"/Learn/Technologies/fraud-proofs-on-bitcoin","permalink":"/docs/Learn/Technologies/fraud-proofs-on-bitcoin","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"sidebar_label":"Fraud Proofs on Bitcoin"},"sidebar":"learnSidebar","previous":{"title":"BitVM-Style Smart Contract","permalink":"/docs/Learn/Technologies/bitvm-smart-contract"},"next":{"title":"Zero-Knowledge Proofs on Bitcoin","permalink":"/docs/Learn/Technologies/zero-knowledge-on-bitcoin"}}');var t=i(4848),r=i(8453);const o={sidebar_position:3,sidebar_label:"Fraud Proofs on Bitcoin"},a="Fraud Proofs on Bitcoin",l={},c=[{value:"Background",id:"background",level:2},{value:"Basic Fraud Proofs",id:"basic-fraud-proofs",level:2},{value:"Workflow of Fraud Proofs",id:"workflow-of-fraud-proofs",level:3},{value:"Dispute Resolution Game",id:"dispute-resolution-game",level:3},{value:"Execution Trace",id:"execution-trace",level:3},{value:"Bisection",id:"bisection",level:3},{value:"Arbitration",id:"arbitration",level:3},{value:"Replacing STF with a ZK Verifier",id:"replacing-stf-with-a-zk-verifier",level:2},{value:"Modeling Fraud Proofs",id:"modeling-fraud-proofs",level:2},{value:"Problem Definition",id:"problem-definition",level:3},{value:"Roles",id:"roles",level:3},{value:"System Model",id:"system-model",level:3},{value:"Workflow",id:"workflow",level:3},{value:"Search and Replay Tradeoff",id:"search-and-replay-tradeoff",level:3},{value:"Instruction-Level vs. Segment-Level Fraud Proofs on Bitcoin",id:"instruction-level-vs-segment-level-fraud-proofs-on-bitcoin",level:2},{value:"Design Principles",id:"design-principles",level:3},{value:"Segment-Level Configuration",id:"segment-level-configuration",level:3},{value:"Building Fraud Proofs with ZK Verifiers on Bitcoin",id:"building-fraud-proofs-with-zk-verifiers-on-bitcoin",level:2}];function h(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"fraud-proofs-on-bitcoin",children:"Fraud Proofs on Bitcoin"})}),"\n",(0,t.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,t.jsxs)(n.p,{children:["Imagine conducting a computation off-chain, referred to as a ",(0,t.jsx)(n.strong,{children:"state transition function (STF)"}),". After completing this computation, you want to publicly verify an assertion about its output on-chain. There are two primary approaches to achieve this:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Validity Proofs:"}),(0,t.jsx)(n.br,{}),"\n","A proof is generated alongside the assertion, and a verifier program runs on-chain using both the assertion and the proof as inputs. If the verifier outputs ",(0,t.jsx)(n.code,{children:"TRUE"}),", the assertion is accepted; otherwise, it is rejected. Zero-knowledge proofs (ZKPs) are the dominant form of validity proofs, though trusted hardware-based proofs, such as those using trusted execution environments (TEEs), also exist."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Fraud Proofs:"}),(0,t.jsx)(n.br,{}),"\n","In this approach, the assertion is optimistically accepted and only finalized after a ",(0,t.jsx)(n.strong,{children:"challenge window"}),' has elapsed (this is referred to as the "happy path"). During this window, anyone can challenge the assertion if they detect fraud. In the event of a challenge, a dispute resolution game is played on-chain between the ',(0,t.jsx)(n.strong,{children:"challenger"})," and the ",(0,t.jsx)(n.strong,{children:"defender"})," (usually the proposer of the assertion). The loser forfeits their deposit as a financial penalty."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This article discusses fraud proofs on Bitcoin. We\u2019ll start by modeling fraud proofs to better understand the challenges of implementing them on Bitcoin. Then, we\u2019ll explore these challenges in detail, and finally, we\u2019ll outline how to build practical fraud proofs for Bitcoin. While the focus is on Bitcoin, we\u2019ll also reference Ethereum\u2019s techniques where relevant, though without delving deeply into their specifics."}),"\n",(0,t.jsx)(n.h2,{id:"basic-fraud-proofs",children:"Basic Fraud Proofs"}),"\n",(0,t.jsxs)(n.p,{children:["Fraud proofs have been successfully implemented in optimistic rollups on Ethereum, with notable examples being ",(0,t.jsx)(n.strong,{children:"Arbitrum"})," and ",(0,t.jsx)(n.strong,{children:"Optimism"}),". These systems rely on fraud proofs to ensure the integrity of off-chain computations."]}),"\n",(0,t.jsx)(n.h3,{id:"workflow-of-fraud-proofs",children:"Workflow of Fraud Proofs"}),"\n",(0,t.jsx)(n.p,{children:"The basic workflow for fraud proofs can be summarized as follows:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Proposing Assertions:"}),(0,t.jsx)(n.br,{}),"\n","A proposer executes the STF off-chain and submits an assertion about the STF result to the base layer (Ethereum for Arbitrum and Optimism, Bitcoin for systems like Bitlayer)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Optimistic Acceptance:"}),(0,t.jsx)(n.br,{}),"\n",'The base layer optimistically accepts the assertion. If no challenges are raised during the predefined challenge window, the assertion is finalized. This is the "happy path."']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Disputes and Challenges:"}),(0,t.jsx)(n.br,{}),"\n","If someone disagrees with the assertion, they can raise a challenge during the window, triggering a dispute resolution game. This game involves a ",(0,t.jsx)(n.strong,{children:"challenger"})," (the one disputing the assertion) and a ",(0,t.jsx)(n.strong,{children:"defender"})," (usually the proposer)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Dispute Resolution Game:"}),(0,t.jsx)(n.br,{}),"\n","The challenger and defender engage in a game to determine the correctness of the assertion. This game is played on-chain."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Outcome and Penalties:"}),(0,t.jsx)(n.br,{}),"\n","The loser of the dispute forfeits their deposit as a financial penalty."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"dispute-resolution-game",children:"Dispute Resolution Game"}),"\n",(0,t.jsx)(n.p,{children:"The simplest way to resolve a dispute is to replay the entire STF on-chain and determine the correct outcome. However, replaying the STF in its entirety is computationally expensive and infeasible on Layer 1 (L1) blockchains due to limited block space. To address this, systems like Arbitrum and Optimism reduce the on-chain footprint by replaying only a single execution step of the STF."}),"\n",(0,t.jsxs)(n.p,{children:["To achieve this, the STF is broken down into discrete execution steps. This process involves generating an ",(0,t.jsx)(n.strong,{children:"execution trace"})," off-chain by running the STF program step by step. Each step in the trace includes:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Input:"})," The pre-execution context (e.g., the state of the virtual machine or blockchain before execution)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Output:"})," A commitment to the updated post-execution context."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The challenger and defender then collaboratively search through the execution trace to identify a single disputed step to replay on-chain. After replaying the step, the updated execution context is compared with the post-execution context commitment in the assertion. If the two do not match, the assertion is invalid."}),"\n",(0,t.jsx)(n.h3,{id:"execution-trace",children:"Execution Trace"}),"\n",(0,t.jsxs)(n.p,{children:["Implementing an interpreter for Ethereum Virtual Machine (EVM) bytecode on-chain is challenging due to the complexity of EVM bytecode. To simplify this process, programs are often compiled into simpler instruction sets, such as ",(0,t.jsx)(n.strong,{children:"RISC-V"})," or ",(0,t.jsx)(n.strong,{children:"MIPS"}),", and the execution trace is generated by running the compiled program. This approach helps manage the dynamic nature of EVM bytecode specifications."]}),"\n",(0,t.jsx)(n.h3,{id:"bisection",children:"Bisection"}),"\n",(0,t.jsxs)(n.p,{children:["To locate the specific step to replay, the challenger and defender use a ",(0,t.jsx)(n.strong,{children:"bisection protocol"}),". Initially, the execution trace is divided into two halves. The parties then iteratively narrow down the search space by bisecting one half until a single step is identified."]}),"\n",(0,t.jsx)(n.h3,{id:"arbitration",children:"Arbitration"}),"\n",(0,t.jsxs)(n.p,{children:["An on-chain smart contract acts as a referee during the dispute resolution game. Its primary responsibility is to prune invalid assertions. If the challenger wins, the assertion is rejected. However, if the defender wins, it does not necessarily mean the assertion is accepted\u2014it simply means the assertion has not been proven invalid. This ensures the ",(0,t.jsx)(n.strong,{children:"safety"})," of the system, as all invalid assertions are pruned. To maintain ",(0,t.jsx)(n.strong,{children:"liveness"}),", other players can propose new assertions."]}),"\n",(0,t.jsx)(n.h2,{id:"replacing-stf-with-a-zk-verifier",children:"Replacing STF with a ZK Verifier"}),"\n",(0,t.jsx)(n.p,{children:"The size of execution traces can vary significantly depending on the block content. Compiling an STF into low-level instructions often inflates the size of the execution trace, making it difficult to predict the number of interactions required in a dispute resolution game. This unpredictability increases costs, especially when the blockchain is congested."}),"\n",(0,t.jsx)(n.p,{children:"Zero-knowledge proofs (ZKPs) offer a solution to this problem. With ZKPs, the following two statements are semantically equivalent:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The STF is correct."}),"\n",(0,t.jsx)(n.li,{children:"The ZK proof of the STF passes verification."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The key advantage of ZKPs is that verifying a proof is computationally much cheaper than executing the original STF, regardless of the number of transactions processed. This asymmetry is critical for scaling blockchains."}),"\n",(0,t.jsx)(n.p,{children:"There are two main approaches to incorporating ZKPs into fraud proofs:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Direct ZK Verification:"}),(0,t.jsx)(n.br,{}),"\n","The challenger submits a ZK proof directly during a dispute. This eliminates the need for instruction-level bisection between the challenger and defender. For example, Optimism is considering adopting this approach."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Fraud Proofs Against a ZK Verifier:"}),(0,t.jsx)(n.br,{}),"\n","In this approach, the STF program is replaced with a ZK verifier in the dispute resolution game. Since the ZK verifier\u2019s execution trace is relatively static, the complexity of the dispute resolution game becomes more predictable. Additionally, this approach simplifies implementation because the ZK verifier can be natively implemented on-chain, avoiding the need for a complex virtual machine interpreter."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"However, generating ZK proofs for STFs remains computationally expensive, which adds costs compared to traditional fraud proofs. Nonetheless, this approach offers significant benefits, particularly for non-Turing-complete blockchains like Bitcoin, where implementing an on-chain VM interpreter is challenging."}),"\n",(0,t.jsx)(n.h2,{id:"modeling-fraud-proofs",children:"Modeling Fraud Proofs"}),"\n",(0,t.jsx)(n.p,{children:"Fraud proofs on Bitcoin are relatively new, and existing models do not adequately describe them. To address this, we need a formal model for fraud proofs. This model will help us better understand and design fraud proofs for Bitcoin."}),"\n",(0,t.jsx)(n.h3,{id:"problem-definition",children:"Problem Definition"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A designated proposer performs an off-chain computation and submits an assertion."}),"\n",(0,t.jsx)(n.li,{children:"A challenger disputes the assertion, triggering a search for a single step in the execution trace to replay on-chain."}),"\n",(0,t.jsx)(n.li,{children:"An on-chain contract arbitrates the dispute and determines the winner."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"roles",children:"Roles"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Proposer:"})," Submits the assertion to Bitcoin."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Challenger:"})," Disagrees with the assertion and initiates a dispute."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"system-model",children:"System Model"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Program:"})," Either the STF program or the ZK verifier of the STF program. A digest of the program is shared among participants."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Replay Unit:"})," The smallest unit of STF execution that can be replayed on-chain."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Replay Target:"})," The specific unit selected for replay."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Replay Result:"})," The pre- and post-execution states of the replayed unit."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Replay Assertion:"})," A combination of the replay target and the corresponding replay result."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For Ethereum, the replay result includes the stack, heap, and state tree. For Bitcoin, it primarily consists of the remaining stack after executing the script."}),"\n",(0,t.jsx)(n.h3,{id:"workflow",children:"Workflow"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Setup:"})," Compile the program into replayable units (e.g., instructions, transactions, or segments)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Commit:"})," The proposer commits to the STF result."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Search:"})," The challenger locates the replay target, either interactively or non-interactively."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Replay:"})," The replay target is executed on-chain, producing a post-execution state."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Arbitrate:"})," The on-chain contract determines the winner based on whether the post-execution state matches the proposer\u2019s commitment."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"search-and-replay-tradeoff",children:"Search and Replay Tradeoff"}),"\n",(0,t.jsx)(n.p,{children:"The granularity of replay units affects the tradeoff between search and replay:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Instruction-level granularity:"})," Billions of replay units, requiring extensive search but minimal replay effort."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Transaction-level granularity:"})," Thousands of replay units, balancing search and replay."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Segment-level granularity:"})," Hundreds of replay units, reducing search complexity but increasing replay workload."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Both Optimism and Arbitrum use instruction-level granularity. On Bitcoin, ",(0,t.jsx)(n.strong,{children:"BitVM1"})," also uses instruction-level granularity, while ",(0,t.jsx)(n.strong,{children:"BitVM2"})," proposes a segment-level approach to reduce search complexity."]}),"\n",(0,t.jsx)(n.h2,{id:"instruction-level-vs-segment-level-fraud-proofs-on-bitcoin",children:"Instruction-Level vs. Segment-Level Fraud Proofs on Bitcoin"}),"\n",(0,t.jsx)(n.h3,{id:"design-principles",children:"Design Principles"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Challenges must be permissionless, allowing any challenger to search for the replay target without requiring coordination with the proposer."}),"\n",(0,t.jsx)(n.li,{children:"The dispute resolution game should conclude within one week, requiring no more than three interactions between the challenger and defender."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"segment-level-configuration",children:"Segment-Level Configuration"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Replay Unit:"})," Segments, with each segment as close to Bitcoin\u2019s upper size limit (4MB) as possible."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Program:"})," A ZK verifier for the STF, written in Bitcoin Script."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Replay Result:"})," The remaining stack and alt stack after executing the segment."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Segments are organized as a ",(0,t.jsx)(n.strong,{children:"taptree"}),", with the proposer committing to all segment values. The challenger selects a segment to replay, and the segment logic is inverted to verify correctness."]}),"\n",(0,t.jsx)(n.h2,{id:"building-fraud-proofs-with-zk-verifiers-on-bitcoin",children:"Building Fraud Proofs with ZK Verifiers on Bitcoin"}),"\n",(0,t.jsx)(n.p,{children:"Creating a ZK verifier for fraud proofs on Bitcoin involves three stages:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Writing the ZK Verifier in Bitcoin Script:"}),(0,t.jsx)(n.br,{}),"\n","Due to Bitcoin Script\u2019s limited expressiveness, implementing a ZK verifier requires numerous optimizations, such as efficient arithmetic operations and cryptographic primitives."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Segmenting the Verifier:"}),(0,t.jsx)(n.br,{}),"\n","The verifier script is divided into multiple segments, each meeting Bitcoin\u2019s runtime constraints."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Linking Segments:"}),(0,t.jsx)(n.br,{}),"\n","The segments are linked to form a complete, consistent ZK verifier. Shared values between segments are pre-committed using bit commitments."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This foundational understanding of fraud proofs on Bitcoin sets the stage for implementing scalable, secure solutions for off-chain computation verification."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);