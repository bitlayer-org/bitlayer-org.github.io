"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5559],{5051:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>a,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"BitVMBridge/Concepts/light-clients","title":"Light Clients for the BitVM Bridge","description":"In this document, we discuss the challenges associated with designing light clients for Bitlayer\'s BitVM Bridge and outline our interim solution and long-term upgrade path.","source":"@site/docs/BitVMBridge/Concepts/006-light-clients.md","sourceDirName":"BitVMBridge/Concepts","slug":"/BitVMBridge/Concepts/light-clients","permalink":"/docs/BitVMBridge/Concepts/light-clients","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"sidebar_label":"Light Clients","slug":"light-clients"},"sidebar":"bitVMBridgeSidebar","previous":{"title":"Key Differentiators","permalink":"/docs/BitVMBridge/Concepts/key-differentiators"},"next":{"title":"Roadmap","permalink":"/docs/BitVMBridge/Concepts/roadmap"}}');var r=t(4848),s=t(8453);const o={sidebar_position:6,sidebar_label:"Light Clients",slug:"light-clients"},l="Light Clients for the BitVM Bridge",a={},c=[{value:"The Role of Light Clients in Trustless Bridges",id:"the-role-of-light-clients-in-trustless-bridges",level:2},{value:"Ideal Verification Flow",id:"ideal-verification-flow",level:3},{value:"Lock Transaction (Peg-In)",id:"lock-transaction-peg-in",level:4},{value:"Burn Transaction (Peg-Out)",id:"burn-transaction-peg-out",level:4},{value:"Light Client Design for the BitVM Bridge",id:"light-client-design-for-the-bitvm-bridge",level:2},{value:"The Three Light Clients",id:"the-three-light-clients",level:3},{value:"Core Challenges",id:"core-challenges",level:3},{value:"The Interim Solution",id:"the-interim-solution",level:2},{value:"Future Upgrades: The Path to Fully Trustless Light Clients",id:"future-upgrades-the-path-to-fully-trustless-light-clients",level:2}];function h(e){const i={blockquote:"blockquote",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"light-clients-for-the-bitvm-bridge",children:"Light Clients for the BitVM Bridge"})}),"\n",(0,r.jsx)(i.p,{children:"In this document, we discuss the challenges associated with designing light clients for Bitlayer's BitVM Bridge and outline our interim solution and long-term upgrade path."}),"\n",(0,r.jsx)(i.h2,{id:"the-role-of-light-clients-in-trustless-bridges",children:"The Role of Light Clients in Trustless Bridges"}),"\n",(0,r.jsxs)(i.p,{children:["To bridge an asset from a source chain to a target chain trustlessly, two smart contracts are required: ",(0,r.jsx)(i.strong,{children:"Contract A"})," on the source chain and ",(0,r.jsx)(i.strong,{children:"Contract B"})," on the target chain. In a typical lock-and-mint bridge, the process works as follows:"]}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Peg-In"}),": A user locks the original asset in Contract A. Contract B on the target chain must independently verify this lock transaction to securely mint a representative (wrapped) asset for the user."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Peg-Out"}),": A user burns the representative asset in Contract B. Contract A on the source chain must independently verify this burn transaction to unlock the original asset for the user."]}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["For this process to be ",(0,r.jsx)(i.strong,{children:"trustless"}),", neither contract can rely on a centralized relayer. Instead, each contract must be able to verify the state of the other chain. This verification is the primary function of a ",(0,r.jsx)(i.strong,{children:"light client"}),"."]}),"\n",(0,r.jsx)(i.h3,{id:"ideal-verification-flow",children:"Ideal Verification Flow"}),"\n",(0,r.jsx)(i.h4,{id:"lock-transaction-peg-in",children:"Lock Transaction (Peg-In)"}),"\n",(0,r.jsx)(i.p,{children:"When bridging from the source chain to the target chain, verification in Contract B should follow these steps:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Block Header Verification"}),": A relayer submits a source chain block header to the source chain light client running on the target chain. The light client verifies the header's validity and confirms it belongs to the canonical chain, eliminating trust in the relayer."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Transaction Inclusion Verification"}),": An SPV (Simple Payment Verification) proof is used to confirm that the lock transaction is included in the verified block."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Transaction Format Verification"}),": The lock transaction's data (e.g., amount locked, recipient address on the target chain) is parsed and checked to ensure it is correctly formatted."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Once these verifications pass, Contract B can safely mint the representative asset."}),"\n",(0,r.jsx)(i.h4,{id:"burn-transaction-peg-out",children:"Burn Transaction (Peg-Out)"}),"\n",(0,r.jsx)(i.p,{children:"The reverse process for unlocking assets on the source chain is symmetric:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Block Header Verification"}),": A relayer submits a target chain block header to the target chain light client running on the source chain."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Transaction Inclusion Verification"}),": An SPV proof verifies the inclusion of the burn transaction."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Transaction Format Verification"}),": The burn transaction's data is checked for correctness."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"After verification, Contract A can safely unlock the original asset. As is clear, robust and trustless light clients are the cornerstone of a secure cross-chain bridge. However, designing them, especially for a Bitcoin bridge, presents significant challenges."}),"\n",(0,r.jsx)(i.h2,{id:"light-client-design-for-the-bitvm-bridge",children:"Light Client Design for the BitVM Bridge"}),"\n",(0,r.jsx)(i.p,{children:"For a Bitcoin bridge, the source chain is Bitcoin, and the target chain is a Turing-complete blockchain like Ethereum. This requires running a Bitcoin light client on Ethereum and an Ethereum light client on Bitcoin. While a Bitcoin light client in Solidity on Ethereum is complex but feasible, the reverse is not possible due to Bitcoin's limited programmability."}),"\n",(0,r.jsxs)(i.p,{children:["This is where the ",(0,r.jsx)(i.strong,{children:"BitVM paradigm"})," provides a solution. It is based on a powerful principle:"]}),"\n",(0,r.jsxs)(i.blockquote,{children:["\n",(0,r.jsx)(i.p,{children:"Verifying a succinct Zero-Knowledge (ZK) proof on-chain is functionally equivalent to confirming the correctness of a complex computation performed off-chain."}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["Using this, we can execute an Ethereum light client within an off-chain zkVM program. A succinct ZK proof of this execution is then generated and submitted to ",(0,r.jsx)(i.strong,{children:"Contract A"})," (a BitVM-style contract) on Bitcoin. If the proof is valid, it guarantees that the off-chain light client execution was correct."]}),"\n",(0,r.jsx)(i.h3,{id:"the-three-light-clients",children:"The Three Light Clients"}),"\n",(0,r.jsx)(i.p,{children:"In total, a complete BitVM Bridge between Bitcoin and Ethereum requires three distinct light clients:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"An Ethereum Light Client in a zkVM Program"}),": This off-chain component, likely written in Rust, verifies Ethereum state transitions for peg-out transactions."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"A Bitcoin Light Client in Contract A"}),": Written in Bitcoin Script, this on-chain light client verifies certain Bitcoin transactions related to the bridge's operational security."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"A Bitcoin Light Client in Contract B"}),": Written in Solidity, this on-chain light client on Ethereum verifies Bitcoin state for peg-in transactions."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"While the third light client is well-understood, the first two introduce novel and significant challenges."}),"\n",(0,r.jsx)(i.h3,{id:"core-challenges",children:"Core Challenges"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Ethereum Light Client in a zkVM Program"}),': A full Ethereum light client is resource-intensive. For instance, verifying signatures from the entire validator set is infeasible within a zkVM. Existing solutions approximate this by verifying signatures only from a smaller sync committee (512 validators), which is a security trade-off. Furthermore, Ethereum light clients are not purely objective; they rely on "subjectivity" assumptions (e.g., Weak Subjectivity) to mitigate long-range attacks, introducing a layer of external trust.']}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Bitcoin Light Client in Contract A"}),": The primary challenge here is determining the canonical Bitcoin chain. Unlike accounts-based chains, Bitcoin's finality is probabilistic and based on accumulated Proof-of-Work. An isolated zkVM program cannot interactively determine the heaviest chain. The solution, inspired by projects like Summa, is to use a ",(0,r.jsx)(i.strong,{children:"fraud-proof-based challenge game"})," where participants can contest submitted block headers. However, this dramatically increases protocol complexity. The transaction graph for such a game can become enormous, and it often requires introducing permissioned watchers, which compromises the permissionless ethos of BitVM."]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"the-interim-solution",children:"The Interim Solution"}),"\n",(0,r.jsx)(i.p,{children:"The Bitlayer team has designed novel solutions for these light client challenges. However, the development, testing, and auditing effort required is substantial. To launch a secure and functional bridge sooner, we have opted for a pragmatic interim solution that reflects a best practice in the industry."}),"\n",(0,r.jsxs)(i.p,{children:["In the current BitVM Bridge implementation, we use a ",(0,r.jsx)(i.strong,{children:"decentralized oracle"})," to submit both Bitcoin and Ethereum block headers. The bridge's attesting committee currently serves as this oracle, providing a secure and reliable data feed for cross-chain state verification."]}),"\n",(0,r.jsx)(i.h2,{id:"future-upgrades-the-path-to-fully-trustless-light-clients",children:"Future Upgrades: The Path to Fully Trustless Light Clients"}),"\n",(0,r.jsx)(i.p,{children:"Our interim solution is a temporary measure. A future major upgrade will replace the oracle system with our fully designed, trust-minimized light clients."}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"For the Ethereum Light Client"}),": We plan to recursively verify ",(0,r.jsx)(i.strong,{children:"Signal proofs"})," (a ZK-based Ethereum light client) within our zkVM program. This will be complemented by novel mechanisms designed to mitigate the long-range attack vector without relying on external subjectivity."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"For the Bitcoin Light Client on Bitcoin"}),": We will implement a streamlined, fraud-proof-based light client protocol. This design is engineered to be efficient while retaining as many permissionless properties as possible, minimizing reliance on a fixed set of watchers."]}),"\n"]})]})}function d(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>o,x:()=>l});var n=t(6540);const r={},s=n.createContext(r);function o(e){const i=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(s.Provider,{value:i},e.children)}}}]);