"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2165],{2998:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"Learn/Bitlayer Rollup/bridge","title":"Trust-minimized BTC Bridge","description":"In a significant advancement for cross-chain interoperability, Bitlayer rollup has integrated the BitVM Bridge to achieve trust-minimized Bitcoin bridging capabilities. Operating as a BitVM-style bridge alongside Bitlayer rollup, this innovative solution implements a front-and-reclaim workflow that leverages pre-signing based smart contracts while utilizing fraud proofs on Bitcoin\'s Layer 1 for optimistic verification of bridge state transitions.","source":"@site/docs/Learn/Bitlayer Rollup/bridge.md","sourceDirName":"Learn/Bitlayer Rollup","slug":"/Learn/Bitlayer Rollup/bridge","permalink":"/docs/Learn/Bitlayer Rollup/bridge","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"sidebar_label":"Trust-minimized BTC Bridge"},"sidebar":"learnSidebar","previous":{"title":"System Design","permalink":"/docs/Learn/Bitlayer Rollup/system-design"},"next":{"title":"Bitlayer Network Whitepaper","permalink":"/docs/Learn/Bitlayer-Whitepaper"}}');var n=t(4848),s=t(8453);const a={sidebar_position:4,sidebar_label:"Trust-minimized BTC Bridge"},o="Trust-minimized BTC Bridge",l={},c=[];function d(e){const i={h1:"h1",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"trust-minimized-btc-bridge",children:"Trust-minimized BTC Bridge"})}),"\n",(0,n.jsx)(i.p,{children:"In a significant advancement for cross-chain interoperability, Bitlayer rollup has integrated the BitVM Bridge to achieve trust-minimized Bitcoin bridging capabilities. Operating as a BitVM-style bridge alongside Bitlayer rollup, this innovative solution implements a front-and-reclaim workflow that leverages pre-signing based smart contracts while utilizing fraud proofs on Bitcoin's Layer 1 for optimistic verification of bridge state transitions."}),"\n",(0,n.jsx)(i.p,{children:"The BitVM Bridge serves as the exclusive minting mechanism for YBTC tokens within Bitlayer V2, ensuring that all minted tokens maintain verifiable backing by Layer 1 Bitcoin. This architectural decision provides DeFi applications on Bitlayer with robust security guarantees regarding asset validity. When combined with complementary bridging solutions such as atomic swaps, users gain the ability to transfer Bitcoin between the base layer and Bitlayer while maintaining minimal trust assumptions."}),"\n",(0,n.jsx)(i.p,{children:"The peg-in process follows a carefully orchestrated sequence where users initiate by broadcasting their request to the network, prompting the committee to respond with pre-signed transactions for the entire transaction graph. Users then verify these pre-signed transactions to ensure the expected flow of Bitcoin before transferring their BTC to a committee-controlled multisig address, which triggers the minting of an equivalent amount of YBTC within the Bitlayer rollup ecosystem."}),"\n",(0,n.jsx)(i.p,{children:"For peg-out operations, users broadcast their request to the network, where liquidity providers acting as brokers facilitate the process by delivering the requested Bitcoin on Layer 1 after users burn their corresponding YBTC on the Bitlayer rollup. The broker then initiates a reclaim process through a Kickoff transaction, which must include both the bridge state transition and its associated zero-knowledge proof, cryptographically verifying the legitimate execution of both the burning event and state advancement across both systems."}),"\n",(0,n.jsx)(i.p,{children:"For comprehensive technical specifications and implementation details, please refer to the BitVM Bridge documentation."})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>a,x:()=>o});var r=t(6540);const n={},s=r.createContext(n);function a(e){const i=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),r.createElement(s.Provider,{value:i},e.children)}}}]);