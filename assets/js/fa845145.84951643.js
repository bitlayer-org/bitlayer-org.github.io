"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3283],{5677:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/p002_1-ed8719b0686bd26fed4ddfd43fb8f4cd.png"},7050:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"Build/CooperationProposals/P002","title":"P002","description":"Status: draft","source":"@site/docs/Build/CooperationProposals/P002.md","sourceDirName":"Build/CooperationProposals","slug":"/Build/CooperationProposals/P002","permalink":"/docs/Build/CooperationProposals/P002","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10},"sidebar":"buildSidebar","previous":{"title":"Token Reputation","permalink":"/docs/Build/BitlayerScanInfoCenter/TokenReputation"},"next":{"title":"P002_zh","permalink":"/docs/Build/CooperationProposals/P002_zh"}}');var s=i(4848),r=i(8453);const a={sidebar_position:10},o="Bitlayer - Liquidity Re-Staking Protocol Collaboration Technical Proposal_English version",l={},d=[{value:"Abstract",id:"abstract",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Specification",id:"specification",level:2},{value:"Layer 2 Staking Contract Specifications",id:"layer-2-staking-contract-specifications",level:3},{value:"Staking",id:"staking",level:4},{value:"Unstaking",id:"unstaking",level:4},{value:"open redemption for the whole plan",id:"open-redemption-for-the-whole-plan",level:5},{value:"Apply for unbinding on demand",id:"apply-for-unbinding-on-demand",level:5},{value:"Permission management specifications",id:"permission-management-specifications",level:3},{value:"Layer 1 Fund Management Specifications",id:"layer-1-fund-management-specifications",level:3},{value:"Layer1 and Layer2 Interaction Plan and Process",id:"layer1-and-layer2-interaction-plan-and-process",level:3}];function c(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Status: draft"}),"\n",(0,s.jsx)(n.p,{children:"Version records:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"2024/09/05 created by Owen,  v0.9.0"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"bitlayer---liquidity-re-staking-protocol-collaboration-technical-proposal_english-version",children:"Bitlayer - Liquidity Re-Staking Protocol Collaboration Technical Proposal_English version"})}),"\n",(0,s.jsx)(n.h2,{id:"abstract",children:"Abstract"}),"\n",(0,s.jsx)(n.p,{children:"In Bitcoin Layer 2 networks like Bitlayer, there is a type of BTC staking project where users can participate in BTC staking activities on Bitlayer (referred to as the Layer 2 network). Simultaneously, the project team stakes the corresponding BTC on the Bitcoin mainnet (Layer 1) associated with the user\u2019s Layer 2 BTC (BL-BTC) into Layer 1 staking protocols (e.g., Babylon), enabling users to earn dual or multiple staking rewards.\nIn the spirit of maintaining network and user asset security, as well as fostering a collaborative and mutually beneficial ecosystem, this document outlines the technical cooperation plan between Bitlayer and liquidity re-staking protocol project teams. The aim is to implement joint management of custodial funds, ensuring the security of users' assets."}),"\n",(0,s.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Due to the limitations of the Bitcoin mainnet, it is not possible to operate liquid staking/re-staking protocols directly on the Bitcoin network. When users participate in these protocols through Bitlayer (Layer 2), the issue of secure custody of Layer 1 assets arises. If the funds staked by users on Layer 2 are entirely entrusted to the project team for withdrawal and movement to Layer 1 for staking, this creates a fully centralized trust model. This poses significant risks to user asset security, the reputation of the Layer 2 network, and the overall prosperity of the ecosystem."}),"\n",(0,s.jsx)(n.li,{children:"Bitlayer is committed to building and developing a Bitcoin Layer 2 network that inherits the security, trustlessness, and programmability of the Bitcoin network. In principle, Bitlayer does not directly participate in the development of on-chain protocols. However, under the premise of ensuring security, Bitlayer will strive to offer users more opportunities to capture yield from their assets, including liquid staking and re-staking protocols."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"specification",children:"Specification"}),"\n",(0,s.jsx)(n.h3,{id:"layer-2-staking-contract-specifications",children:"Layer 2 Staking Contract Specifications"}),"\n",(0,s.jsx)(n.h4,{id:"staking",children:"Staking"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"When a user participates in staking, a staking event needs to be triggered. The event is defined as follows:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"event TokenStaked(uint256 indexed reqId, address indexed user, uint256 indexed amount, address token, uint256 planId, uint256 duration, bytes extraInfo);\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The protocol must provide a globally unique ID for each user interaction, ",(0,s.jsx)(n.code,{children:"reqId"}),", to ensure the uniqueness of the event identification."]}),"\n",(0,s.jsxs)(n.li,{children:["tokenrefers to the contract address of cryptocurrency. For a native token, use the 0 address to represent\uff08 ",(0,s.jsx)(n.code,{children:"0x0000000000000000000000000000000000000000"}),"\uff09."]}),"\n",(0,s.jsx)(n.li,{children:"Staking activities can be carried out in stages, and the staking/unstaking operations on the Bitcoin network can be performed as a whole according to the total amount of each stage. In this situation, the planId can be used to identify which stage the user is participating in."}),"\n",(0,s.jsx)(n.li,{children:"For duration Staking Duration ,and extraInfo Extra Custom Information, are all optional and can be extended as needed."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"unstaking",children:"Unstaking"}),"\n",(0,s.jsx)(n.p,{children:"Supports two ways to unstake:  open redemption for the whole plan and on-demand application (early) unbinding."}),"\n",(0,s.jsx)(n.h5,{id:"open-redemption-for-the-whole-plan",children:"open redemption for the whole plan"}),"\n",(0,s.jsx)(n.p,{children:"The contract provides the following functions for Bitlayer to agree to open redemption:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function approveWithdraw(uint256 planId);\n"})}),"\n",(0,s.jsx)(n.h5,{id:"apply-for-unbinding-on-demand",children:"Apply for unbinding on demand"}),"\n",(0,s.jsx)(n.p,{children:"Need to be performed in steps:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"When a user requests to unstake, the following event is emitted:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"event UnboundRequired(uint256 indexed reqId, address indexed user, uint256 indexed amount, address token, bytes extraInfo);\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Once Bitlayer (the official cross-chain bridge) receives the corresponding funds from Layer 1, it approves the user's unstaking request. The Layer 2 staking contract should provide the following interface (supporting batch releases) and emit the following event"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function approveUnbound(uint256[] reqIds);\nevent UnboundApproved(uint256 indexed reqId, bytes extraInfo);\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"The users' final withdrawal of the staked principal, including the relevant functions and events, is determined by the protocol and is not covered in this proposal."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"permission-management-specifications",children:"Permission management specifications"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The staking contract should aim to be as decentralized as possible, minimizing centralized management authority."}),"\n",(0,s.jsxs)(n.li,{children:["All management permissions related to using or transferring of funds within the contract must be governed by a multi-signature wallet, DAO contract, or other decentralized governance solutions. Bitlayer must be an indispensable participant in this governance. Relevant permissions include, but are not limited to:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Contract upgrade permissions;"}),"\n",(0,s.jsx)(n.li,{children:"Permissions to directly withdraw or transfer user funds within the staking contract;"}),"\n",(0,s.jsx)(n.li,{children:"Permissions to execute arbitrary code (such functions should be avoided if possible; if necessary, they must be controlled by multi-signature approval)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"layer-1-fund-management-specifications",children:"Layer 1 Fund Management Specifications"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Must use MPC self-custody or third-party custody, and provide a dedicated wallet account."}),"\n",(0,s.jsx)(n.li,{children:"Account management permissions must be jointly managed by the project and Bitlayer."}),"\n",(0,s.jsx)(n.li,{children:"Custody services must include a whitelist function; the dedicated wallet can only transfer funds to whitelist addresses and perform staking."}),"\n",(0,s.jsx)(n.li,{children:"Set Bitlayer's official bridge hot wallet as a whitelist address; any changes to the whitelist must be approved by Bitlayer."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"layer1-and-layer2-interaction-plan-and-process",children:"Layer1 and Layer2 Interaction Plan and Process"}),"\n",(0,s.jsx)(n.p,{children:"The process is shown in the figure below\uff1a"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:i(5677).A+"",width:"1844",height:"1146"})}),"\n",(0,s.jsx)(n.p,{children:"Please note\uff1a"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["In Step 3 and Step 7, transfers of funds between the bridge hot wallet and the dedicated staking wallet must include the reqId from the layer2 user's staking/unstaking request to ensure order association.\uff1b","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The method for including the reqId in transactions: Provide an OP_RETURN UTXO including a JSON string with the content: ",(0,s.jsx)(n.code,{children:'{"StReqIds":"id1,id2"}'}),", where multiple IDs are separated by commas, such as ",(0,s.jsx)(n.code,{children:'{"StReqIds":"100,101"}'}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["If, due to certain objective constraints, this cannot be achieved, the Bridge Relayer will release funds based on the principles of amount matching and first-come, first-served approval. If there is no single unbonding request that exactly matches the current received amount, the funds will be released according to the first-come, first-served principle by combining requests as needed.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["For example: If there are three requests with amounts of 1 BTC, 2 BTC, and 1 BTC, respectively, and the bridge hot wallet receives a transfer of 3 BTC from the dedicated staking wallet, the first two requests will be released in the order of their submission.\nIn addition, for the case of unified redemption, step 5 in the above figure is not required, and step 8 is changed to execute the ",(0,s.jsx)(n.code,{children:"approveWithdraw(uint256 planId)"})," function."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(6540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);