<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Learn/Bitlayer-Whitepaper" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">Bitlayer Network: The Computational Layer for Bitcoin | Bitlayer</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://docs.bitlayer.org/docs/Learn/Bitlayer-Whitepaper"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Bitlayer Network: The Computational Layer for Bitcoin | Bitlayer"><meta data-rh="true" name="description" content="2.0"><meta data-rh="true" property="og:description" content="2.0"><link data-rh="true" rel="icon" href="/img/bitlayer.ico"><link data-rh="true" rel="canonical" href="https://docs.bitlayer.org/docs/Learn/Bitlayer-Whitepaper"><link data-rh="true" rel="alternate" href="https://docs.bitlayer.org/docs/Learn/Bitlayer-Whitepaper" hreflang="en"><link data-rh="true" rel="alternate" href="https://docs.bitlayer.org/docs/Learn/Bitlayer-Whitepaper" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Bitlayer Network Whitepaper","item":"https://docs.bitlayer.org/docs/Learn/Bitlayer-Whitepaper"}]}</script><link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3DF3TS5JQ"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-R3DF3TS5JQ",{anonymize_ip:!0})</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.c5284178.css">
<script src="/assets/js/runtime~main.30f45cd6.js" defer="defer"></script>
<script src="/assets/js/main.16116fe3.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/Bitlayer_docs.svg" alt="Bitlayer Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/Bitlayer_docs.svg" alt="Bitlayer Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Bitlayer</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/Learn/Introduction">Learn@Bitlayer</a><a class="navbar__item navbar__link" href="/docs/Build/GettingStarted/QuickStart">Build@Bitlayer</a><a class="navbar__item navbar__link" href="/docs/BitVMBridge/Concepts/overview">BitVM Bridge</a><a class="navbar__item navbar__link" href="/docs/YBTCFamily/bl_btc_overview">YBTC Family</a><a href="https://blog.bitlayer.org/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://www.bitlayer.org/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Bitlayer<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><a href="https://github.com/bitlayer-org" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input" value=""><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" href="/docs/Learn/Introduction/">Introduction</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Introduction/">Welcome to Bitlayer Documentation</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" tabindex="0" href="/docs/Learn/Introduction/BTRToken/en">BTR Token</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Introduction/BTRToken/en">BTR Token Overview</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Introduction/BTRToken/zh">BTR 代币简介</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Introduction/Roadmap">Roadmap</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" href="/docs/Learn/Bitlayer PoS/Overview">Bitlayer PoS (V1)</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/Overview">Overview</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/AboutGas">About Gas</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/Networks">Network</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/Bridges">Bridges</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/POR">Proof of Reserve</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/Json-RPC">JSON-RPC</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/Contracts">Utility Contracts</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/PegTokens">Peg Tokens</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/BitlayerVsEth">Bitlayer VS. Ethereum</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/AboutFinality">About finality</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" href="/docs/Learn/Bitlayer Rollup/overview">Bitlayer Rollup (V2)</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer Rollup/overview">Overview</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer Rollup/system-design">System Design</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer Rollup/bridge">Trust-minimized BTC Bridge</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/Learn/Bitlayer-Whitepaper">Bitlayer Network Whitepaper</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" href="/docs/Learn/Technologies/overview">Technologies</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Technologies/overview">Overview</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Technologies/bitvm-smart-contract">BitVM-Style Smart Contract</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Technologies/fraud-proofs-on-bitcoin">Fraud Proofs on Bitcoin</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Technologies/zero-knowledge-on-bitcoin">Zero-Knowledge Proofs on Bitcoin</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/Learn/FAQs/Frequently-asked-questions">MISC</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/Learn/Terms/BTCFi/Desyn/user-agreement">Terms</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">Bitlayer Network Whitepaper</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Bitlayer Network: The Computational Layer for Bitcoin</h1></header>
<center>2.0</center>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="abstract">Abstract<a href="#abstract" class="hash-link" aria-label="Direct link to Abstract" title="Direct link to Abstract">​</a></h3>
<p>Bitcoin&#x27;s limited transaction throughput and programmability hinder its potential in Decentralized Finance (DeFi). Existing Layer 2 solutions often introduce new trust assumptions, failing to anchor their security directly to Bitcoin&#x27;s consensus. This paper introduces Bitlayer, a Layer 2 network that solves this challenge using the BitVM paradigm. Our core contribution is a novel, recursive verification protocol that, for the first time, enables a continuous chain of Layer 2 state transitions to be verifiably settled on Bitcoin. This moves beyond mere data inscription to achieve security rooted in Bitcoin&#x27;s proof-of-work. Furthermore, we deeply integrate BitVM bridge with our rollup protocol to enable secure transfers of Bitcoin assets. Finally, we designed a modular and Turing-complete execution engine, which, powered by a fast consensus mechanism, provides users with sub-second soft finality. Bitlayer unlocks Bitcoin&#x27;s vast, untapped capital for a new generation of decentralized applications, laying a foundational infrastructure for the Bitcoin DeFi ecosystem.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-introduction">1. Introduction<a href="#1-introduction" class="hash-link" aria-label="Direct link to 1. Introduction" title="Direct link to 1. Introduction">​</a></h2>
<p>Bitcoin <a href="#ref1">[1]</a> holds immense potential for Decentralized Finance (DeFi), but its core design limits transaction throughput and programmability. Activating Bitcoin&#x27;s vast, untapped capital thus depends on secure and scalable Layer 2 solutions.</p>
<p>However, existing approaches to scaling Bitcoin fall short. Sidechains that rely on federated multisignatures introduce centralized trust, fundamentally undermining Bitcoin&#x27;s security model. Meanwhile, early rollup designs for Bitcoin can post transaction data to the L1 but lack a mechanism to enforce the validity of state transitions on-chain. This leaves them vulnerable, as their security is not fully guaranteed by Bitcoin&#x27;s consensus.</p>
<p>This raises a critical question: is it possible to build a Bitcoin L2 that achieves scalable computation while ensuring state validity is enforced by the Bitcoin mainnet itself, without new trust assumptions?</p>
<p>This paper introduces Bitlayer, a Layer 2 network that provides an affirmative answer through rollup architecture <a href="#ref7">[7]</a>. and the BitVM paradigm <a href="#ref2">[2]</a>. overcoming the limitations of both the Bitcoin and existing Layer 2 solutions by enabling scalable computation while anchoring its security to the underlying Bitcoin blockchain. Our primary contributions are as follows:</p>
<ul>
<li><strong>A Modular and Turing-Complete Execution Layer</strong>: We design and implement a modular execution layer that enables Turing-complete smart contracts, leveraging a meticulously designed blockchain protocol to achieve sub-second soft finality and provide a responsive experience ideal for demanding applications like DeFi and gaming.</li>
<li><strong>A Recursive Bitcoin Settlement Protocol for Rollups</strong>: We design and formalize the first rollup protocol that uses a recursive BitVM-based framework to settle a continuous claim chain of Layer 2 state transitions on Bitcoin. This provides security by anchoring the L2&#x27;s validity directly to the L1.</li>
<li><strong>A Synergistic Integration of Bridge and Rollup</strong>: We design and implement a secure asset bridge inspired by the BitVM bridge architecture. The core innovation is its deep integration with our rollup protocol, which ensures that asset security and rollup validity are governed by a unified trust model, enabling seamless and secure asset transfers.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-network-architecture">2. Network Architecture<a href="#2-network-architecture" class="hash-link" aria-label="Direct link to 2. Network Architecture" title="Direct link to 2. Network Architecture">​</a></h2>
<p>Bitlayer operates on a dual-level architecture that combines a Proof-of-Stake (PoS) consensus for fast block production with a rollup framework that anchors its security to the Bitcoin network. The PoS layer allows validators to sequence transactions and produce blocks rapidly, providing a high-throughput, EVM-compatible environment. The rollup layer then periodically commits and settles the state of this L2 chain onto the Bitcoin blockchain. This design leverages Bitcoin as the ultimate layer for security and data availability, while Bitlayer Network serves as a scalable and efficient computational layer.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="21-network-participants-and-roles">2.1. Network Participants and Roles<a href="#21-network-participants-and-roles" class="hash-link" aria-label="Direct link to 2.1. Network Participants and Roles" title="Direct link to 2.1. Network Participants and Roles">​</a></h3>
<p>The network is maintained by two key participants: Validators, and Full Nodes.</p>
<ul>
<li><strong>Validators</strong>: Validators form the backbone of the PoS consensus. They are responsible for producing and validating L2 blocks, ensuring the network&#x27;s safety and liveness. To join the validator set, a candidate must stake BTR tokens, and their influence in the consensus is proportional to their total stake, which can include tokens delegated by other BTR holders.<!-- -->
<ul>
<li><strong>Rollup Operator</strong>: The Rollup Operator is a specialized, rotating role assigned to a single validator from the set. This operator is responsible for bundling L2 state transitions into batches, generating cryptographic proofs, and submitting them for settlement on the Bitcoin L1. To ensure accountability and disincentivize fraud, the operator must lock a significant amount of BTC as collateral on L1. The operator role rotates periodically to prevent censorship and centralization.</li>
</ul>
</li>
<li><strong>Full Nodes</strong>: Full nodes maintain a complete copy of the Bitlayer Network blockchain, independently verifying all transactions and state transitions without trusting validators. They play a crucial role in enforcing the protocol rules and ensuring network transparency.</li>
</ul>
<p><img decoding="async" loading="lazy" alt="Network Architecture" src="/assets/images/network_architecture-81f5116b6a14af5a59b1da6a17ccad0f.png" width="2792" height="1832" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="22-dual-level-transaction-finality">2.2. Dual-Level Transaction Finality<a href="#22-dual-level-transaction-finality" class="hash-link" aria-label="Direct link to 2.2. Dual-Level Transaction Finality" title="Direct link to 2.2. Dual-Level Transaction Finality">​</a></h3>
<p>Bitlayer offers a dual-level finality model, giving users and applications a choice between speed and Bitcoin-level security.</p>
<ul>
<li><strong>Soft Finality</strong>: A transaction achieves soft finality in sub-second once the block containing it is confirmed by Bitlayer&#x27;s PoS consensus. This provides a fast and responsive user experience, with security backed by the economic stake of the validator set.</li>
<li><strong>Hard Finality</strong>: Hard finality is the highest security guarantee, achieved when the L2 state containing the transaction is settled and finalized on the Bitcoin blockchain. Due to the optimistic rollup&#x27;s challenge period, this takes approximately seven days. The security for hard finality relies on only a single honest party to challenge fraud, making it nearly equivalent to Bitcoin&#x27;s own security.</li>
</ul>
<p>In the rare event of a successful L1 challenge that creates a discrepancy between the L2 state and the settled L1 state, the protocol is designed to halt. The network&#x27;s recovery would then be guided by social consensus among stakeholders to ensure the integrity of user assets.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="3-settling-l2-state-on-bitcoin">3. Settling L2 State on Bitcoin<a href="#3-settling-l2-state-on-bitcoin" class="hash-link" aria-label="Direct link to 3. Settling L2 State on Bitcoin" title="Direct link to 3. Settling L2 State on Bitcoin">​</a></h2>
<p>As a Layer 2 rollup, Bitlayer derives its security from Bitcoin. This chapter details the core mechanism that underpins this relationship: settlement. Settlement is the process by which L2 state transitions, executed in Bitlayer&#x27;s high-throughput environment, are committed to and finalized on the Bitcoin L1. This allows Bitlayer to inherit Bitcoin&#x27;s security guarantees. The challenge, however, is achieving this on Bitcoin&#x27;s constrained, non-Turing-complete script environment.</p>
<p>Our solution is a novel settlement protocol inspired by the BitVM paradigm. This chapter systematically deconstructs this protocol. We first define the concepts of a state claim and explain our hybrid verification approach. After introducing the necessary cryptographic primitives, we detail the protocol for settling a single state claim. Finally, we show how this is extended into a recursive protocol that settles a continuous chain of L2 claims, forming the backbone of the entire rollup.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="31-defining-the-l2-state-claim">3.1. Defining the L2 State Claim<a href="#31-defining-the-l2-state-claim" class="hash-link" aria-label="Direct link to 3.1. Defining the L2 State Claim" title="Direct link to 3.1. Defining the L2 State Claim">​</a></h3>
<p>At its core, a blockchain is defined by a <strong>State Transition Function (STF)</strong>, denoted as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Υ</mi></mrow><annotation encoding="application/x-tex">\Upsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Υ</span></span></span></span>. This deterministic function dictates how the network&#x27;s <strong>State (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">s</span></span></span></span>)</strong> evolves. A state, which includes all account balances and contract data, is represented by a 32-byte Merkle root. The STF takes the current state <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">s_{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> and a batch of L2 <strong>Transaction Batch (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">T</span></span></span></span>)</strong> to produce the next state <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">s_{t+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span></span></span></span>:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>s</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi mathvariant="normal">Υ</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>t</mi></msub><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s_{t+1} = \Upsilon(s_t, T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">Υ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mclose">)</span></span></span></span></span>
<p>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span></span></span></span> is the index of transaction batch. The entire history of the blockchain unfolds from an initial <strong>genesis state (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>)</strong>.</p>
<p>A <strong>State Claim (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Φ</span></span></span></span>)</strong> is a formal assertion submitted by a Rollup Operator to a smart contract on the Bitcoin L1. Its purpose is to commit to a new L2 state that has resulted from processing a specific transaction batch. This claim acts as the anchor, linking L2 activity to the L1 and enabling Bitlayer Network to inherit Bitcoin&#x27;s security.</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>s</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>s</mi><mi>t</mi></msub><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Phi = \{s_{t-1}, s_t, T\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Φ</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mclose">}</span></span></span></span></span>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="32-cryptographic-primitives">3.2. Cryptographic Primitives<a href="#32-cryptographic-primitives" class="hash-link" aria-label="Direct link to 3.2. Cryptographic Primitives" title="Direct link to 3.2. Cryptographic Primitives">​</a></h3>
<p>The settlement protocol relies heavily on two advanced cryptographic primitives: Succinct Non-interactive Arguments (SNARGs) and Hash-based One-Time Signature scheme.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="321-groth16-snarg">3.2.1. Groth16 SNARG<a href="#321-groth16-snarg" class="hash-link" aria-label="Direct link to 3.2.1. Groth16 SNARG" title="Direct link to 3.2.1. Groth16 SNARG">​</a></h4>
<p>Following the Groth16 paper <a href="#ref4">[4]</a>, a SNARG for a relation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.00773em">R</span></span></span></span> consists of three probabilistic polynomial-time algorithms (<code>Setup</code>, <code>Prove</code>, <code>Vfy</code>):</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>←</mo><mtext mathvariant="monospace">SNARG.Setup</mtext><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta \leftarrow \texttt{SNARG.Setup}(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord texttt">SNARG.Setup</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mclose">)</span></span></span></span>: A setup algorithm that produces a common reference string <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span></span></span></span> for a given relation.</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>←</mo><mtext mathvariant="monospace">SNARG.Prove</mtext><mo stretchy="false">(</mo><mi>R</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><mi mathvariant="normal">Φ</mi><mo separator="true">,</mo><mi>ω</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi \leftarrow \texttt{SNARG.Prove}(R, \delta, \Phi, \omega)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">π</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord texttt">SNARG.Prove</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">Φ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">ω</span><span class="mclose">)</span></span></span></span>: A prover algorithm that, given the common reference string <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span></span></span></span>, a claim <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Φ</span></span></span></span>, and a witness <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">ω</span></span></span></span>, generates a proof argument <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">π</span></span></span></span>.</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn><mo>←</mo><mtext mathvariant="monospace">SNARG.Vfy</mtext><mo stretchy="false">(</mo><mi>R</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><mi mathvariant="normal">Φ</mi><mo separator="true">,</mo><mi>π</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">0/1 \leftarrow \texttt{SNARG.Vfy}(R, \delta, \Phi, \pi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">0/1</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord texttt">SNARG.Vfy</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">Φ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">π</span><span class="mclose">)</span></span></span></span>: A verification algorithm that accepts or rejects the proof.</li>
</ul>
<p>The SNARG satisfies perfect completeness, computational soundness, and what we define as full succinctness.</p>
<p><strong>Definition 3.1 (Full Succinctness):</strong> A protocol (<code>Setup</code>, <code>Prove</code>, <code>Vfy</code>) is fully succinct if the verifier <code>Vfy</code> runs in time polynomial in the security parameter <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">λ</span></span></span></span>, and the size of the proof <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">π</span></span></span></span> is also polynomial in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">λ</span></span></span></span>.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="322-hash-based-one-time-signature-hots">3.2.2. Hash-based One-Time Signature (HOTS)<a href="#322-hash-based-one-time-signature-hots" class="hash-link" aria-label="Direct link to 3.2.2. Hash-based One-Time Signature (HOTS)" title="Direct link to 3.2.2. Hash-based One-Time Signature (HOTS)">​</a></h4>
<p>The Bitcoin script language, with its <code>OP_CHECKSIG</code> opcode <a href="#ref6">[6]</a>, is designed to verify signatures for transactions, not for arbitrary off-chain messages. While proposals like BIP348 exist to extend this functionality, they require a network consensus change. To overcome this limitation, We utilize a Hash-based One-Time Signature scheme (<code>HOTS</code>) [5, 8]. This approach is particularly advantageous as hash functions are native and computationally inexpensive operations within Bitcoin script.</p>
<p>Our variant of <code>HOTS</code> consists of four algorithms:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mi>k</mi><mo separator="true">,</mo><mi>p</mi><mi>k</mi><mo stretchy="false">)</mo><mo>←</mo><mtext mathvariant="monospace">HOTS.setup</mtext><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(sk, pk) \leftarrow \texttt{HOTS.setup}(\lambda)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord texttt">HOTS.setup</span></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mclose">)</span></span></span></span>: Generates a secret key and public key pair from a security parameter.</li>
<li><code>s</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo><mtext mathvariant="monospace">HOTS.publish</mtext><mo stretchy="false">(</mo><mi>p</mi><mi>k</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\leftarrow \texttt{HOTS.publish}(pk, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord texttt">HOTS.publish</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>: Publishes a commitment to the Bitcoin script, preparing it to verify a signature for a message of length <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">b</span></span></span></span>.</li>
<li><code>w</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo><mtext mathvariant="monospace">HOTS.sign</mtext><mo stretchy="false">(</mo><mi>s</mi><mi>k</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\leftarrow \texttt{HOTS.sign}(sk, m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord texttt">HOTS.sign</span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>: Signs a message <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span> with the secret key to produce a witness <code>w</code>.</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>←</mo><mtext mathvariant="monospace">HOTS.verify</mtext><mo stretchy="false">(</mo><mi>p</mi><mi>k</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0/1, m) \leftarrow \texttt{HOTS.verify}(pk, w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0/1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord texttt">HOTS.verify</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="mclose">)</span></span></span></span>: Verifies the witness <code>w</code>. If valid, it returns <code>1</code> and reveals the original message <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span> on the stack for further on-chain processing.</li>
</ul>
<p>This final property—the on-chain revelation of the signed message—is a critical component for linking consecutive state claims, as will be detailed in Section 3.5.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="33-protocol-overview">3.3. Protocol Overview<a href="#33-protocol-overview" class="hash-link" aria-label="Direct link to 3.3. Protocol Overview" title="Direct link to 3.3. Protocol Overview">​</a></h3>
<p>The entire settlement protocol is embodied in a BitVM-style smart contract, which is not a single, monolithic contract but rather a complex graph of pre-signed Bitcoin transactions. Participants must jointly pre-sign this transaction graph and are bound to interact strictly according to its predefined pathways. Whereas the original BitVM protocol focused on settling claims about events on both external chain and the Bitcoin for bridging purposes <a href="#ref3">[3]</a>, Bitlayer&#x27;s protocol is more intricate. It must settle a continuous <em>sequence</em> of claims, each representing a discrete change in the L2 state, and guarantee that this sequence is consecutive and unbroken.</p>
<p>The protocol can be conceptualized as a recursive structure. In Section 3.4, we will first elaborate on the sub-protocol for settling a single state claim. Then, in Section 3.5, we will detail how this single-claim verification mechanism is recursively embedded within a broader protocol that settles a continuous chain of claims. By combining these two components, we construct the complete rollup protocol for settling the Bitlayer Network state on Bitcoin.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="34-settling-a-single-claim">3.4. Settling a Single Claim<a href="#34-settling-a-single-claim" class="hash-link" aria-label="Direct link to 3.4. Settling a Single Claim" title="Direct link to 3.4. Settling a Single Claim">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="341-the-bitvm2-paradigm">3.4.1. The BitVM2 Paradigm<a href="#341-the-bitvm2-paradigm" class="hash-link" aria-label="Direct link to 3.4.1. The BitVM2 Paradigm" title="Direct link to 3.4.1. The BitVM2 Paradigm">​</a></h4>
<p>The on-chain verification of a claim is conducted optimistically. The verifier program in our case is expressed in Bitcoin script. However, as demonstrated by the groundbreaking work of the BitVM Alliance on a Groth16 verifier, a monolithic implementation of such a verifier is far too large to execute directly within a single Bitcoin transaction. Therefore, the BitVM2 paradigm <a href="#ref2">[2]</a> splits the large verifier program into a chain of smaller sub-programs, or &quot;chunks.&quot; The protocol then proceeds as a fraud-proof game, where it is assumed the operator&#x27;s claim is correct unless a challenger can pinpoint an incorrect computation step between two specific chunks.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="342-protocol-roles">3.4.2. Protocol Roles<a href="#342-protocol-roles" class="hash-link" aria-label="Direct link to 3.4.2. Protocol Roles" title="Direct link to 3.4.2. Protocol Roles">​</a></h4>
<p>The BitVM smart contract for claim settlement involves a well-defined set of participants:</p>
<ol>
<li><strong>Attesting Committee:</strong> Rather than forming a new entity, the existing validator set of the Bitlayer Network serves as the attesting committee. This committee is collectively responsible for pre-signing the transaction graph that defines the protocol.</li>
<li><strong>Protocol Participants:</strong> The active participants in the settlement game include a single, designated <strong>Operator</strong> responsible for submitting claims and any number of <strong>Watchers</strong>. Watchers can be anyone, including other validators, and their role is to monitor the operator and challenge fraudulent claims.</li>
</ol>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="343-single-claim-verification-protocol">3.4.3. Single Claim Verification Protocol<a href="#343-single-claim-verification-protocol" class="hash-link" aria-label="Direct link to 3.4.3. Single Claim Verification Protocol" title="Direct link to 3.4.3. Single Claim Verification Protocol">​</a></h4>
<p>The protocol for verifying a single claim unfolds as a timed challenge-response game governed by Bitcoin time locks. It ensures that both the Operator and any Watcher must act within specified time bounds or face penalties. The protocol can be broken down into three primary stages, which correspond to a series of interconnected Bitcoin transactions pre-signed by the Attesting Committee.</p>
<p><img decoding="async" loading="lazy" alt="Single Claim Verification Protocol" src="/assets/images/single_claim_verification-c94230f74a63b7fac54b4cb8d0fb6427.png" width="4508" height="2036" class="img_ev3q"></p>
<p><strong>1. Setup Stage</strong>
Before the game begins, a trusted public setup generates the necessary scripts. The STF (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Υ</mi></mrow><annotation encoding="application/x-tex">\Upsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Υ</span></span></span></span>) is used to create a common reference string <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span></span></span></span> via <code>SNARG.Setup</code>. The verifier program <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">)</mo><mo>=</mo><mtext mathvariant="monospace">SNARG.Vfy</mtext><mo stretchy="false">(</mo><mi>R</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><mi mathvariant="normal">Φ</mi><mo separator="true">,</mo><mi>π</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(\pi) = \texttt{SNARG.Vfy}(R, \delta, \Phi, \pi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em">π</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord texttt">SNARG.Vfy</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">Φ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">π</span><span class="mclose">)</span></span></span></span> is split into a set of smaller sub-programs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>f</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>I</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{f_i(I_i)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)}</span></span></span></span>. Three types of locking scripts are created: a <code>Claim Script</code> to initiate the process, an <code>Assert Script</code> for the Operator to post results of all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>, and a set of <code>Disprove Scripts</code>, one for each sub-program, which Watchers can use to prove fraud. The Claim Script and Assert Script are composed of multiple HOTS, which force operator to post signed claim and results of all sub-programs. The Disprove Scripts include all sub-programs and are organized within a Taproot address. These scripts are then embedded into the outputs of the pre-signed transaction graph.</p>
<p><strong>2. Claim Stage</strong>
The Operator initiates the process by publishing a <em>Claim</em> transaction, which spends from a previous UTXO and locks their collateral (e.g., <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">d</span></span></span></span> BTC). To unlock this input, the Operator must use their HOTS key to sign and reveal the state claim <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\Phi_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>. This action starts a timer, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mrow><mi>c</mi><mi>h</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Delta_{challenge}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">ha</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">ll</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">g</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span>. Watchers observe this claim and can run the STF locally. If they find the claim to be invalid, they can issue a <em>Challenge</em> transaction before the timeout. If no challenge occurs, the Operator reclaims their collateral via an <em>Optimistic Acceptance</em> transaction, and the claim is considered settled.</p>
<p><strong>3. Challenge and Resolution Stage</strong>
If a Watcher issues a <em>Challenge</em> transaction (which may require them to post a smaller collateral, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">c</span></span></span></span> BTC, to deter frivolous challenges), the pessimistic path is taken. The Operator is now compelled to execute an <em>Assert</em> transaction. In doing so, they must run the chunked verifier program locally and use their HOTS key to sign and publish the results of <em>all</em> sub-programs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>f</mi><mi>i</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{f_i\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>. This action starts another timer, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>v</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Delta_{disprove}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">ro</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span>.</p>
<p>The Watcher now examines the sequence of results published by the Operator. If the Watcher can find a single sub-program <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> where the Operator&#x27;s published output is inconsistent with the execution of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> on the Operator&#x27;s published inputs, they have found fraud. The Watcher can then construct a <em>Disprove</em> transaction. This transaction spends the output corresponding to the fraudulent sub-program, executing that small chunk of logic on-chain to prove the inconsistency. A successful <em>Disprove</em> transaction forfeits the Operator&#x27;s collateral, a portion of which (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">a</span></span></span></span> BTC, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&gt;</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a &gt; c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">c</span></span></span></span>) is awarded to the Watcher. If the Operator correctly publishes results of all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>, and the Watcher fails to submit a valid <em>Disprove</em> transaction in time, the Operator can finalize the claim via an <em>Acceptance</em> transaction and recover their collateral.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="344-security-properties">3.4.4. Security Properties<a href="#344-security-properties" class="hash-link" aria-label="Direct link to 3.4.4. Security Properties" title="Direct link to 3.4.4. Security Properties">​</a></h4>
<p>This protocol is designed to be secure under the assumption of at least one honest Watcher. Its security rests on three key properties, which are analyzed in detail in Chapter 6.2.</p>
<ul>
<li><strong>Completeness:</strong> An honest Operator who correctly follows the protocol and submits valid state claims will never be unjustly penalized.</li>
<li><strong>Soundness:</strong> A dishonest Operator who submits a fraudulent claim cannot avoid being penalized, as an honest Watcher will always be able to construct a valid <em>Disprove</em> transaction.</li>
<li><strong>Efficiency:</strong> The entire claim verification process, whether it results in acceptance or rejection, is guaranteed to terminate within a bounded timeframe defined by the protocol&#x27;s time locks.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="35-settling-a-chain-of-claims">3.5. Settling a Chain of Claims<a href="#35-settling-a-chain-of-claims" class="hash-link" aria-label="Direct link to 3.5. Settling a Chain of Claims" title="Direct link to 3.5. Settling a Chain of Claims">​</a></h3>
<p>The protocol described above is sufficient for settling a single, isolated claim. However, a rollup requires the continuous settlement of a sequence of claims that represents the ongoing evolution of the L2 state. This is achieved by extending the protocol to recursively chain claims together.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="351-linking-claims-with-hots">3.5.1. Linking Claims with HOTS<a href="#351-linking-claims-with-hots" class="hash-link" aria-label="Direct link to 3.5.1. Linking Claims with HOTS" title="Direct link to 3.5.1. Linking Claims with HOTS">​</a></h4>
<p>The key to chaining claims lies in the transaction graph&#x27;s structure. Each <em>Claim</em> transaction, in addition to its other outputs, creates a special UTXO called a <strong>claim connector</strong>. To submit the next claim (Claim <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span>), the Operator must spend the claim connector UTXO created by the transaction for Claim <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span>. The locking script for this connector requires the Operator to use their HOTS key to sign and reveal the data package for Claim <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span>. This design naturally links adjacent claims into a chronological and unforgeable chain, as each claim transaction can only be created by consuming an output from its direct predecessor. Bitcoin time locks are used to enforce a regular cadence, preventing the Operator from submitting claims either too quickly or too slowly.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="352-the-trunk-transaction-graph-and-parallel-verification">3.5.2. The Trunk Transaction Graph and Parallel Verification<a href="#352-the-trunk-transaction-graph-and-parallel-verification" class="hash-link" aria-label="Direct link to 3.5.2. The Trunk Transaction Graph and Parallel Verification" title="Direct link to 3.5.2. The Trunk Transaction Graph and Parallel Verification">​</a></h4>
<p>This recursive structure results in a transaction graph with a primary <strong>trunk</strong> that links the sequence of claims. At each claim on the trunk, a complete sub-graph for single-claim verification (as described in Section 3.4) branches off.</p>
<p>A critical feature of this design is that the submission of the next claim does not need to wait for the final resolution of the previous claim&#x27;s verification sub-protocol. The Operator can submit Claim <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> while the challenge window for Claim <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span> is still open. This parallelism is efficient but requires a mechanism to handle cascading failures. If Claim <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span> is successfully challenged, the protocol ensures that its state is invalid, which automatically invalidates the premise of all subsequent claims (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>N</mi><mo>+</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">N+1, N+2, \ldots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="minner">…</span></span></span></span>). A rational Operator, upon having a claim successfully challenged, is economically incentivized to cease submitting further claims, as each would require posting collateral that is doomed to be forfeited. The trunk would then terminate via a <code>ClaimTimeout</code> transaction.</p>
<p><img decoding="async" loading="lazy" alt="The Trunk Transaction Graph" src="/assets/images/trunk_graph-7e45811d75337dbcbe8a1062ea8c7406.png" width="3808" height="1764" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="353-transaction-graph-reconfiguration-and-epochs">3.5.3. Transaction Graph Reconfiguration and Epochs<a href="#353-transaction-graph-reconfiguration-and-epochs" class="hash-link" aria-label="Direct link to 3.5.3. Transaction Graph Reconfiguration and Epochs" title="Direct link to 3.5.3. Transaction Graph Reconfiguration and Epochs">​</a></h4>
<p>Constructing, pre-signing, and storing a transaction graph intended to last for the entire lifecycle of the rollup (e.g., 100 years) is computationally and logistically infeasible for validators. It would also require an impossibly large amount of BTC to be locked as collateral upfront and would preclude any future protocol upgrades.</p>
<p>To solve these problems, we introduce <strong>Reconfiguration</strong>. The protocol&#x27;s timeline is divided into discrete <strong>epochs</strong>, with each epoch consisting of a fixed number of claims (e.g., lasting for two weeks). At the transition between epochs, a reconfiguration event occurs. For each attesting ceremony, the validator set only needs to pre-sign the trunk transaction graph for the upcoming epoch. This makes the burden on validators manageable.</p>
<p><strong>The Exit Window:</strong> Reconfiguration is also the point at which protocol upgrades or changes to the validator set can occur. These changes may alter the security assumptions or trust parameters of the system. To protect user sovereignty, Bitlayer provides a mandatory <strong>Exit Window</strong>. The configuration for Epoch <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">N+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">2</span></span></span></span> is proposed and finalized during Epoch <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span>. This gives users the entirety of Epoch <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> to review the new validator set and transaction graph for Epoch <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">N+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">2</span></span></span></span>. If a user does not approve of the upcoming changes, they have a full epoch to exit the system by withdrawing their assets (e.g., pegging-out BTC via the BitVM Bridge) before the new configuration takes effect.</p>
<p><strong>Validator Incentives:</strong> All validators are required to stake BTR tokens to participate. The pre-signing ceremony for each epoch&#x27;s transaction graph is coordinated through a system contract on the L2. Failure to participate in the ceremony in a timely manner results in the forfeiture of a portion of the validator&#x27;s staked BTR, strongly disincentivizing attacks designed to stall the protocol.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="354-the-reconfiguration-process">3.5.4. The Reconfiguration Process<a href="#354-the-reconfiguration-process" class="hash-link" aria-label="Direct link to 3.5.4. The Reconfiguration Process" title="Direct link to 3.5.4. The Reconfiguration Process">​</a></h4>
<p>The reconfiguration process is orchestrated by the L2 system contract. The designated operator prepares all necessary information for the next epoch&#x27;s transaction graph, and each validator independently generates it, signs it, and submits their signature to the L2 contract. Once a supermajority (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>−</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">N-f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span></span></span></span>) of valid signatures are collected, they are aggregated, and the attestation is complete.</p>
<p>This process culminates in a <strong>Reconfiguration transaction</strong> on Bitcoin. This transaction locks the aggregate collateral required for all claims in the new epoch and records the updated configuration parameters, such as the verifier program commitment <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span></span></span></span>, the operator&#x27;s identity, and time lock values. <strong>Reconfiguration transactions</strong> must be issued immediately after pre-signing is completed to promptly announce configurations. The very first such transaction, the <strong>Epoch 0 Reconfiguration transaction</strong>, bootstraps the entire rollup protocol and records the genesis state <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> of the Bitlayer Network.</p>
<p><img decoding="async" loading="lazy" alt="Transaction Graph Reconfiguration" src="/assets/images/reconfiguration-5fa663624d8f41c3e317e99c4392b104.png" width="3740" height="1860" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="36-summary">3.6. Summary<a href="#36-summary" class="hash-link" aria-label="Direct link to 3.6. Summary" title="Direct link to 3.6. Summary">​</a></h3>
<p>In summary, the Bitlayer settlement protocol materializes as a perpetual, yet manageable, BitVM-style transaction graph on Bitcoin. This graph is cyclic, composed of per-epoch sub-graphs that are linked together through reconfiguration transactions. Each epoch&#x27;s sub-graph contains a trunk of chronologically linked state claims, and each claim is accompanied by its own verification sub-graph—a sophisticated challenge-response game that allows any single honest participant to enforce the correctness of the L2 state. This architecture enables Bitlayer to achieve a high degree of scalability and programmability while being securely anchored to Bitcoin&#x27;s unparalleled proof-of-work consensus.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="4-state-transition-function-and-batch-execution">4. State Transition Function and Batch Execution<a href="#4-state-transition-function-and-batch-execution" class="hash-link" aria-label="Direct link to 4. State Transition Function and Batch Execution" title="Direct link to 4. State Transition Function and Batch Execution">​</a></h2>
<p>While Chapter 3 established the protocol for settling a state claim on Bitcoin, this chapter defines the computational process that a claim asserts to be valid: the Bitlayer STF. A correct state transition over a batch of L2 blocks is the fundamental unit of progress for the rollup. Here, we specify the components of our unique, EVM-based STF and present the multi-stage, recursive proving pipeline that generates proofs for its execution. This entire computational process is what an Operator asserts with their claim and what any Watcher can challenge through the settlement game.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="41-the-bitlayer-network-stf">4.1. The Bitlayer Network STF<a href="#41-the-bitlayer-network-stf" class="hash-link" aria-label="Direct link to 4.1. The Bitlayer Network STF" title="Direct link to 4.1. The Bitlayer Network STF">​</a></h3>
<p>The Bitlayer Network&#x27;s STF aligns with the battle-tested principles of the Ethereum EVM <a href="#ref9">[9]</a> to provide a familiar and powerful environment for developers. As a Bitcoin rollup, however, it extends the EVM with additional system-level logic and specialized contracts to address its unique requirements, such as handling bridged Bitcoin assets and processing messages from the L1.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="411-gas-and-fees">4.1.1. Gas and Fees<a href="#411-gas-and-fees" class="hash-link" aria-label="Direct link to 4.1.1. Gas and Fees" title="Direct link to 4.1.1. Gas and Fees">​</a></h4>
<p>Transaction fees on the Bitlayer Network are paid exclusively in <strong>BTC</strong>. This design choice provides a seamless and consistent experience for Bitcoin users, as they can use the asset they already hold without needing to acquire a new, native token for network operations. While transactions are paid for in BTC, the fee rates are extremely low, reflecting the efficiency of the Layer 2 architecture.</p>
<p>Bitlayer implements a multi-dimensional gas model that separates transaction costs into three distinct components:</p>
<ul>
<li><strong>Execution Fee</strong>: Covers the computational cost of executing the transaction in the EVM, similar to the standard Ethereum model.</li>
<li><strong>Storage Fee</strong>: Accounts for the cost of modifying the L2 state, such as creating new accounts or updating contract storage.</li>
</ul>
<p>The Execution and Storage Fees are distributed among the validators who secure the network. This fee distribution mechanism creates a precise and sustainable economic model.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="412-protocol-contracts">4.1.2. Protocol Contracts<a href="#412-protocol-contracts" class="hash-link" aria-label="Direct link to 4.1.2. Protocol Contracts" title="Direct link to 4.1.2. Protocol Contracts">​</a></h4>
<p>Protocol contracts are a set of special-purpose smart contracts that exist at genesis and form an <em>integral part</em> of the Bitlayer protocol. While their logic is central to the network&#x27;s operation, implementing them as smart contracts rather than native code provides a clear interface and allows for future upgrades through the established governance procedure.</p>
<p><strong>System Config Contract</strong>
The System Config contract acts as the network&#x27;s central control panel, managing core protocol parameters as key-value pairs. Examples include the block gas limit (<code>&lt;block_gas_limit, 10,000,000&gt;</code>) and validator set size.</p>
<ul>
<li><strong>Reconfigurability</strong>: Most parameters can be updated via governance proposals.</li>
<li><strong>Update Cadence</strong>: The timing of these updates depends on their impact. Some parameters, like certain fee multipliers, can be adjusted at any block boundary. Others that have deeper systemic effects, such as those related to the consensus engine, can only be modified at an epoch boundary to ensure a safe and orderly transition.</li>
<li><strong>Security</strong>: Since many of these parameters are read directly by native protocol code, modifications must be carefully evaluated to ensure they do not compromise network stability or security.</li>
</ul>
<p><strong>Validator Management Contract</strong>
This contract governs the lifecycle of the Bitlayer Network&#x27;s validator set, which is crucial for both L2 block production and L1 attestation ceremonies.</p>
<ul>
<li><strong>Validator Admission and Removal</strong>:<!-- -->
<ul>
<li>To become a validator candidate, a user must stake a minimum amount of BTR tokens in this contract. Candidates are promoted to the active validator set at the beginning of the next epoch. To maintain network stability, the number of new validators promoted from the candidate queue to the active set is capped in each epoch (e.g., at 10% of the total set size).</li>
<li>Voluntary exits by active validators are similarly subject to a per-epoch cap.</li>
<li>A validator whose stake falls below the required minimum due to slashing will be forcibly removed from the active set at the next epoch boundary.</li>
</ul>
</li>
<li><strong>Operator Election</strong>:<!-- -->
<ul>
<li>For each epoch, the protocol selects one Rollup Operator from the active validator set. The selected Operator is then required to submit a collateral deposit transaction on the Bitcoin L1 within a specified time frame. Failure to do so penalizes the non-compliant validator and triggers a new election to ensure the liveness of the settlement process.</li>
</ul>
</li>
<li><strong>Rewards and Penalties</strong>:<!-- -->
<ul>
<li>Validators are rewarded with BTR tokens for securing the network. Rewards are distributed in proportion to each validator&#x27;s total stake.</li>
<li>The L2 block proposer receives transaction fee and a larger share of the block reward.</li>
<li>The designated Rollup Operator receives additional BTR rewards to compensate for the operational costs of settling state claims on Bitcoin L1.</li>
<li>Validators who participate in the pre-signing ceremony for each epoch&#x27;s transaction graph receive attestation rewards.</li>
<li>Failure to adhere to protocol rules (e.g., missing block votes, failing to participate in the pre-signing ceremony) results in penalties, where a portion of the validator&#x27;s staked BTR is slashed.</li>
</ul>
</li>
</ul>
<p><strong>Bitcoin Light Client (BLC) Contract</strong>
The BLC contract serves as the network&#x27;s trustless gateway to the Bitcoin L1. It has two primary responsibilities: tracking the canonical Bitcoin chain and processing L1-to-L2 messages.</p>
<ul>
<li><strong>Canonical Chain Tracking</strong>: The protocol relies on oracles to submit Bitcoin block headers to the BLC. By default, the Rollup Operator fulfills this role. However, if the Operator fails to do so, anyone can submit the block header, ensuring liveness. The BLC contract tracks all submitted headers, including those from ephemeral forks, and maintains the canonical chain by following the heaviest-chain rule. A submitted block is then considered finalized after accruing a number of subsequent confirmations defined by a threshold in the <strong>System Config Contract</strong> (e.g., six).</li>
<li><strong>L1-to-L2 Message Processing</strong>: The BLC contract scans finalized Bitcoin blocks for specific L1-to-L2 messages and translates them into executable L2 transactions called <strong>intrinsic transactions</strong>. These messages include:<!-- -->
<ul>
<li><strong>Bridge Deposit Events</strong>: When a user deposits BTC into the BitVM bridge contract on L1, they inscribe a <code>Bridge Deposit Event</code>. The BLC contract detects this event and generates a corresponding <code>Bridge-Mint</code> intrinsic transaction on L2 to credit the user with the equivalent wrapped asset. This automates the peg-in process without requiring a separate user action on L2.</li>
<li><strong>Forced Transactions</strong>: A user can force the inclusion of an L2 transaction by inscribing its data directly onto the Bitcoin blockchain. This provides a powerful censorship-resistance mechanism, ensuring that a user can always interact with the rollup even if the entire L2 validator set attempts to censor them.</li>
</ul>
</li>
</ul>
<p>The protocol enforces the timely processing of these messages through both its consensus and rollup mechanisms:</p>
<ul>
<li><strong>Consensus Enforcement</strong>: Before proposing a new block, a validator must query the BLC contract to generate any pending intrinsic transactions. These transactions must be included at the very beginning of the proposed block, ahead of any regular user transactions. If the number of intrinsic transactions exceeds the capacity of a single L2 block, they are processed across multiple blocks in a deterministic order.</li>
<li><strong>Rollup Enforcement</strong>: The STF definition requires that a state claim for a batch of L2 blocks must correctly process <em>all</em> L1-to-L2 messages from the corresponding finalized Bitcoin blocks. Any Operator who submits a claim based on a state that omits or incorrectly processes an L1 message has submitted a fraudulent claim and will be successfully challenged and penalized.</li>
</ul>
<p><strong>Bridge Contract</strong>
The Bridge Contract on L2 works in tandem with the BitVM bridge contract on L1 to facilitate the secure, bidirectional flow of assets.</p>
<ul>
<li><strong>Peg-In</strong>: The contract processes the <code>Bridge-Mint</code> intrinsic transactions generated by the BLC, minting the corresponding L2 wrapped assets to the user&#x27;s account.</li>
<li><strong>Peg-Out</strong>: To withdraw assets, a user initiates a transaction on L2 that calls the Bridge Contract. The contract burns the user&#x27;s L2 assets and emits an L2 event. This event serves as a message that is later picked up by the L1 bridge mechanism to process the withdrawal.</li>
<li><strong>Proof of Reserves (PoR)</strong>: The contract maintains a complete and transparent ledger of all bridged assets on Bitlayer, enabling anyone to generate a Proof of Reserves at any time.</li>
</ul>
<p>The detailed architecture of the bridge and the peg-out mechanism will be further explored in Chapter 5.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="42-proving-pipeline">4.2. Proving Pipeline<a href="#42-proving-pipeline" class="hash-link" aria-label="Direct link to 4.2. Proving Pipeline" title="Direct link to 4.2. Proving Pipeline">​</a></h3>
<p>To verify the state transitions of this Rollup protocol, the protocol adopts a multi-stage, asynchronous, recursive proving system based on a zero-knowledge virtual machine (zkVM). The system is designed to generate a wrapped proof that is both compact and easy to verify on the Bitcoin network, while ensuring the entire proving system is secure and upgradable through a governed process.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="421-integrity-and-upgradability-via-codecontrolgroup">4.2.1. Integrity and Upgradability via <code>CodeControlGroup</code><a href="#421-integrity-and-upgradability-via-codecontrolgroup" class="hash-link" aria-label="Direct link to 421-integrity-and-upgradability-via-codecontrolgroup" title="Direct link to 421-integrity-and-upgradability-via-codecontrolgroup">​</a></h4>
<p>The integrity of the entire proving pipeline depends on the ability to ensure the validity and integrity of its core computation engine—that is, all programs running in the zkVM, including the block execution logic, batch aggregation logic, and recursion logic. The <code>CodeControlGroup</code> is the core security mechanism designed for this purpose.</p>
<p><strong><code>CodeCommitment</code>: The Unique Fingerprint of a zkVM Program</strong>
The zkVM generates an unique cryptographic commitment for each complete program suite, known as the <code>CodeCommitment</code>. This commitment serves as a unique and immutable fingerprint for a specific version of the program. Any change to the code, no matter how small, results in a completely different <code>CodeCommitment</code>. This holistic commitment is crucial, as it effectively prevents attack vectors where a fraudulent proof is generated by tampering with some components while others appear unchanged.</p>
<p><strong><code>CodeControlGroup</code>: An Index-Based Authorization Registry</strong>
The <code>CodeControlGroup</code> is a cryptographically enforced authorization list that records all valid <code>CodeCommitment</code>s. Its core design is not a flat set, but rather an <strong>index-based structure</strong>. Throughout the proving pipeline, every program execution occurs within a specific context, which is marked by a unique <strong>Index</strong> (e.g., a block height). The <code>CodeControlGroup</code> maps each <code>Index</code> to a whitelist of valid <code>CodeCommitment</code>s. Its data structure is a <strong>Hierarchical Merkle Trees with Merkle Mountain Range (MMR)</strong>.</p>
<p>This index-based mechanism is critical. It allows the system to precisely determine whether the program used was on the whitelist for that specific <code>Index</code> when verifying any historical proof. This ensures the integrity of all programs throughout the entire recursive chain, precluding the possibility of using unauthorized or outdated program versions to generate historical proofs. The root, the <code>CodeControlRoot</code>, serves as a commitment to the entire authorization history, making the registry itself tamper-evident.</p>
<p><strong>Secure Upgrade Path</strong>
The system&#x27;s upgrade path is structured around discrete <strong>Epochs</strong> (as described in Section 3.5.3). Changes are introduced via an <strong>Epoch Reconfiguration</strong> event at each transition. This event defines the new set of system parameters, with the <code>CodeControlGroup</code> being a critical component, and this data is submitted to both Bitcoin and the L2. To simplify pipeline implementation and trust management, the proving pipeline does not scan blocks for this information. Instead, it receives the appropriate <code>CodeControlGroup</code> for a given context as a direct configuration input. The integrity of this entire process is guaranteed by the synchronization between the Epoch transition and the <strong>pre-signing</strong> mechanism. The new <code>CodeControlGroup</code> is finalized by governance, and its corresponding <code>CodeControlRoot</code> is locked in on-chain via the pre-signing mechanism before the new Epoch becomes active. This ensures that if a prover uses an incorrect <code>CodeControlGroup</code>, the resulting proof will be rejected during on-chain verification, as its <code>CodeControlRoot</code> will not match the pre-signed value for that Epoch. Therefore, the <code>CodeControlGroup</code> provides a transparent and secure governance framework for the evolution of the zkVM&#x27;s core logic. Its root, the <code>CodeControlRoot</code>, serves as the final commitment to the system&#x27;s complete authorized history, anchoring the validity of the entire recursive proof chain in a foundation of cryptographic certainty and governance consensus.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="422-the-four-stage-recursive-proving-pipeline">4.2.2. The Four-Stage Recursive Proving Pipeline<a href="#422-the-four-stage-recursive-proving-pipeline" class="hash-link" aria-label="Direct link to 4.2.2. The Four-Stage Recursive Proving Pipeline" title="Direct link to 4.2.2. The Four-Stage Recursive Proving Pipeline">​</a></h4>
<p><strong>Overview</strong>
The protocol&#x27;s proving workflow is a sequential pipeline consisting of four distinct stages. Before delving into the stages, it is important to understand the basic data structures involved. Each <strong>Block</strong> has a unique <strong>Block Number</strong>, which serves as the <strong>Index</strong> for contextual verification within the <code>CodeControlGroup</code>. Blocks are grouped into a <strong>Batch</strong> for aggregation. The criterion for forming a batch is a key, governable system parameter, which can be either a fixed number of blocks or a specific time duration. Finally, the protocol&#x27;s timeline is organized into <strong>Epochs</strong> to manage system-wide reconfigurations.</p>
<p>The four stages of the pipeline are: <strong>Single Block Proving</strong>, <strong>Batch Aggregation</strong>, <strong>Batch Recursion</strong>, and <strong>Proof Wrapping</strong>. This structure operates as a nested pipeline: within each batch, proofs flow sequentially through the stages, while a higher-level pipeline links consecutive batches together through the recursive stage. Each stage receives specific inputs, performs computations within the zkVM, and generates outputs that either feed into the next stage or contribute to the wrapped proof. This recursive architecture enables the efficient aggregation and compression of proofs, thereby enhancing system scalability. The following diagram illustrates this nested pipeline structure.</p>
<p><img decoding="async" loading="lazy" alt="Architecture of the proving pipeline, illustrated with a batch size of three blocks." src="/assets/images/proving_pipeline-8332584ceb8881f3a54d21e96a3c4887.png" width="5672" height="3276" class="img_ev3q"></p>
<p><strong>Pipeline Design Rationale</strong>
The multi-stage pipeline design is a deliberate architectural choice made to optimize the trade-offs among proving efficiency, system complexity, and security.</p>
<ul>
<li><strong>Parallelization in Stage 1 for Efficiency</strong>: Proving the state transition of a single block is the most computationally intensive task in the entire process. By isolating the proving process for each block, the protocol can initiate proving tasks without waiting for a complete batch to be formed. This allows blocks to be processed in parallel as soon as they are generated, maximizing the utilization of prover resources and significantly improving overall proving efficiency.</li>
<li><strong>Timing in Stage 2 for Simplified Complexity</strong>: Compared to the first stage, the task of aggregating multiple block proofs into a single batch proof is far less computationally intensive and much faster. Therefore, the protocol chooses to initiate the aggregation stage only after all blocks within a batch have been proven, rather than adopting a more complex incremental aggregation approach. This design effectively reduces the management complexity of the <code>CodeControlGroup</code>, as the context for the aggregation operation is a well-defined, completed batch.</li>
<li><strong>Separation of Duties in Stage 3 for Integrity</strong>: Batch recursion is the key to ensuring integrity and achieving recursive compression. Separating it from the aggregation process is intended to create a clear division of responsibilities. The aggregation stage focuses on &quot;intra-batch&quot; state continuity, while the recursion stage handles &quot;inter-batch&quot; linking, connecting the validity of the current batch to the entire history of the chain. Its proving task is also more advanced and does not need to be executed concurrently with aggregation.</li>
</ul>
<p>In summary, the entire system employs a pipelined execution of proofs not only within a single batch but also constitutes a higher-level pipeline across multiple batches. This nested pipeline design ensures high efficiency while keeping the verification logic of the <code>CodeControlGroup</code> within manageable limits, thereby guaranteeing the system&#x27;s security and the convenience of upgrades.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="423-stage-1-single-block-proving">4.2.3. Stage 1: Single Block Proving<a href="#423-stage-1-single-block-proving" class="hash-link" aria-label="Direct link to 4.2.3. Stage 1: Single Block Proving" title="Direct link to 4.2.3. Stage 1: Single Block Proving">​</a></h4>
<p>The objective of this stage is to generate a validity proof for the execution of a single block. The process involves two steps:</p>
<ol>
<li><strong>Off-Chain Simulation</strong>: Before proof generation begins, the system first simulates the execution of the block outside the zkVM. This step aims to acquire all necessary input data for the proof, including the <strong>read-write sets</strong> and their corresponding <strong>Merkle proofs</strong>.</li>
<li><strong>Stateless Proof Generation</strong>: The input data obtained from the previous step is provided to a stateless zkVM instance. The zkVM re-executes the state transition in a closed environment and generates a zero-knowledge proof.</li>
</ol>
<p>The output of this stage is a <strong>Single Block Proof</strong>, which asserts the correctness of the block&#x27;s execution. Its core content encapsulates the state roots before and after the block&#x27;s execution (<code>FromState</code> and <code>ToState</code>), the unique block identifier (<code>BlockNumber</code>), and the commitment to the program used to generate this proof (<code>CodeCommitment</code>).</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="424-stage-2-batch-aggregation">4.2.4. Stage 2: Batch Aggregation<a href="#424-stage-2-batch-aggregation" class="hash-link" aria-label="Direct link to 4.2.4. Stage 2: Batch Aggregation" title="Direct link to 4.2.4. Stage 2: Batch Aggregation">​</a></h4>
<p>This stage aims to aggregate the <strong>Single Block Proof</strong> from multiple consecutive blocks within a batch into a single proof. It performs two core functions:</p>
<ol>
<li><strong>Verifying State Continuity</strong>: It checks and ensures that the state transitions between adjacent block proofs are continuous. That is, the <code>ToState</code> of block <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span> must be identical to the <code>FromState</code> of block <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span>.</li>
<li><strong>Recording Program Commitments</strong>: It extracts the <code>CodeCommitment</code> from each input proof and <strong>records</strong> it. A key feature of this stage is that it only records the commitments; verification against the <code>CodeControlGroup</code> is deferred to the next stage.</li>
</ol>
<p>The output of this stage is a <strong>Batch Aggregated Proof</strong>, which represents the correctness of the entire batch&#x27;s execution. This proof encapsulates the overall state transition of the batch, including the block height range of the batch (starting <code>BlockNumber</code> and ending <code>BlockNumber</code>), the initial state root of the first block in the batch (<code>FromState</code>), the final state root of the last block (<code>ToState</code>), and a complete list of the program commitments (<code>CodeCommitment</code>) recorded from all proofs within the batch.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="425-stage-3-batch-recursion">4.2.5. Stage 3: Batch Recursion<a href="#425-stage-3-batch-recursion" class="hash-link" aria-label="Direct link to 4.2.5. Stage 3: Batch Recursion" title="Direct link to 4.2.5. Stage 3: Batch Recursion">  ​</a></h4>
<p>This is the core recursive step of the pipeline, designed to compress the ever-growing chain of proofs into a proof of constant size. The inputs for this stage consist of two parts:</p>
<ol>
<li>The <strong>Batch Aggregated Proof</strong> of the current batch (from Stage 2).</li>
<li>The <strong>Batch Recursive Proof</strong> from the previous batch (from the previous run of Stage 3). For the system&#x27;s first batch, this input does not exist; instead, the initial state root (<code>FromState</code>) of its aggregated proof is checked directly against the protocol&#x27;s <code>GenesisState</code> to anchor the beginning of the entire proof chain.</li>
</ol>
<p>The core task performed by the zkVM in this stage is to comprehensively verify the authorization history of all executed program versions against the <code>CodeControlGroup</code>. This verification is based on the specific context (<code>BlockNumber</code>) in which each program was executed, as reflected in the following checks:</p>
<ul>
<li><strong>Verifying Block Execution Programs</strong>: For each <strong>Single Block Proof</strong> in the batch, its <code>CodeCommitment</code> is verified against the <code>CodeControlGroup</code> using its corresponding <code>BlockNumber</code> as the <code>Index</code>.</li>
<li><strong>Verifying Aggregation Program</strong>: The <code>CodeCommitment</code> of the current aggregation logic (Stage 2) is verified against the <code>CodeControlGroup</code> to its execution context.</li>
<li><strong>Verifying Recursion Program</strong>: The <code>CodeCommitment</code> of the program used for the previous recursive proof is also verified against the <code>CodeControlGroup</code> using its corresponding historical context.</li>
</ul>
<p>In this way, the chain of trust is correctly propagated from the <code>GenesisState</code> through each recursion. The output of this stage is a new, updated <strong>Recursive Proof</strong> that encapsulates the history of all processed batches to date.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="426-stage-4-proof-wrapping">4.2.6. Stage 4: Proof Wrapping<a href="#426-stage-4-proof-wrapping" class="hash-link" aria-label="Direct link to 4.2.6. Stage 4: Proof Wrapping" title="Direct link to 4.2.6. Stage 4: Proof Wrapping">​</a></h4>
<p>This stage is the endpoint of the pipeline of the batch proving, with the core objective of converting the recursion proof from the previous stage into a highly optimized wrapped proof suitable for final verification on the Bitcoin network.</p>
<p>It takes the latest recursive proof and &quot;wraps&quot; it into a wrapped <strong>Groth16</strong> proof. The Groth16 proving system is chosen for its ability to generate proofs of extremely small size and support exceptionally fast verification, which is crucial for achieving efficient verification under the computational and cost constraints of Bitcoin Script.</p>
<p>During the generation of this wrapped proof, the program version of the input recursive proof is verified against the <code>CodeControlGroup</code>. The complete <code>CodeControlGroup</code> is also compressed into its Merkle root, the <code>CodeControlRoot</code>, which is included as a public input in the wrapped proof. As the top-level program in the trust hierarchy, the wrapping program itself is not contained within the <code>CodeControlGroup</code>; its integrity is instead guaranteed by having its <code>CodeCommitment</code> directly hard-coded into the on-chain verification script.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="43-on-chain-verification-via-bitcoin-script">4.3. On-Chain Verification via Bitcoin Script<a href="#43-on-chain-verification-via-bitcoin-script" class="hash-link" aria-label="Direct link to 4.3. On-Chain Verification via Bitcoin Script" title="Direct link to 4.3. On-Chain Verification via Bitcoin Script">​</a></h3>
<p>The on-chain verification script template serves as the final arbiter of trust. As a result of the governance and pre-signing process synchronized with the Epoch lifecycle (as described in Section 4.4.1.1), a set of immutable trust anchors are hard-coded into the script for each Epoch. These anchors include:</p>
<ul>
<li>The <code>GenesisState</code>, which anchors the starting point of the state.</li>
<li>The <code>CodeControlRoot</code>, which commits to the entire authorization history of all upgradable programs for that Epoch.</li>
<li>The <code>CodeCommitment</code> of the non-upgradable wrapping program (Stage 4), which serves as the ultimate verifier.</li>
</ul>
<p>During verification, the wrapped proof itself and its public inputs (including <code>FromState</code>, <code>ToState</code>, and <code>CodeControlRoot</code>) are provided as dynamic data. The core logic of the on-chain script is to <strong>check</strong> whether the <code>CodeControlRoot</code> provided as a public input in the proof exactly matches the <code>CodeControlRoot</code> hard-coded in the script for that Epoch. Based on this, the script combines these dynamic inputs with the static anchors to form a comprehensive <code>ClaimHash</code>. Subsequently, the BitVM protocol optimistically invokes the ZK proof verification logic. If the verification succeeds, it confirms the following facts:</p>
<ol>
<li>The state transition from <code>FromState</code> to <code>ToState</code> is computationally valid according to the rules enforced by the zkVM programs.</li>
<li>All programs within the recursive proof were authorized by the <code>CodeControlRoot</code>.</li>
<li>The wrapped proof was generated by the authorized wrapping program.</li>
<li>The entire computational history can be traced back to the <code>GenesisState</code>.</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="5-bridging-bitcoin-and-bitlayer-network">5. Bridging Bitcoin and Bitlayer Network<a href="#5-bridging-bitcoin-and-bitlayer-network" class="hash-link" aria-label="Direct link to 5. Bridging Bitcoin and Bitlayer Network" title="Direct link to 5. Bridging Bitcoin and Bitlayer Network">​</a></h2>
<p>A secure rollup requires a correspondingly secure mechanism for asset transfers between the L1 and L2. This chapter details the Bitlayer Asset Bridge, the mechanism for transferring assets between Bitcoin and the Bitlayer Network. The bridge is built upon the same BitVM paradigm as our settlement protocol, ensuring a unified security model for both state validity and asset custody.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="51-roles">5.1. Roles<a href="#51-roles" class="hash-link" aria-label="Direct link to 5.1. Roles" title="Direct link to 5.1. Roles">​</a></h3>
<p>The bridge protocol involves several key roles:</p>
<ol>
<li><strong>Users:</strong> Asset holders who initiate transfers between Bitcoin and Bitlayer Network.</li>
<li><strong>Broker:</strong> Assists users in preparing deposits and withdrawals, including constructing initial transaction graphs and obtaining signatures from Attesters. Brokers directly interface with users, abstracting the complexity of the BitVM protocol and enabling seamless interaction.</li>
<li><strong>Attesting Committee:</strong> This is the same validator set from the rollup protocol. The committee elected for a specific Epoch N is responsible for pre-signing the transaction graphs for all bridge requests initiated within that epoch.</li>
<li><strong>Watcher:</strong> Permissionless observers who monitor the protocol and challenge malicious behavior.</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="52-asset-cross-chain-flow">5.2. Asset Cross-Chain Flow<a href="#52-asset-cross-chain-flow" class="hash-link" aria-label="Direct link to 5.2. Asset Cross-Chain Flow" title="Direct link to 5.2. Asset Cross-Chain Flow">​</a></h3>
<p>Below we use BTC as an example to introduce the complete process of asset deposit and withdrawal.</p>
<p><img decoding="async" loading="lazy" alt="Asset Cross-Chain Flow" src="/assets/images/asset_flow-3eb996b40c875efb224ba925ba36ecd0.png" width="4392" height="1364" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="521-asset-deposit-peg-in">5.2.1. Asset Deposit (Peg-in)<a href="#521-asset-deposit-peg-in" class="hash-link" aria-label="Direct link to 5.2.1. Asset Deposit (Peg-in)" title="Direct link to 5.2.1. Asset Deposit (Peg-in)">​</a></h4>
<p>The peg-in process moves assets from Bitcoin to Bitlayer and is initiated by the user in several steps:</p>
<ol>
<li><strong>Initiate Request:</strong> The user submits a <strong>PeginRequest</strong> to all brokers, specifying the UTXOs for deposit, the target Bitlayer Network address, and a Bitcoin address for transaction change.</li>
<li><strong>Preparation:</strong> Each broker responds with a complete <strong>Pegin transaction</strong> and the associated transaction graph. The user must carefully verify all received transaction graphs for correctness, ensuring their parameters meet all expectations.</li>
<li><strong>Broadcast &amp; Mint:</strong> After verification, the user issues the <strong>Pegin transaction</strong> on the Bitcoin network. Once the Pegin transaction is confirmed on L1, it is detected by the <strong>Bitcoin Light Client</strong> on the Bitlayer Network (as described in Chapter 4), which in turn triggers the Bitlayer protocol to automatically generate an intrinsic transaction. This transaction then calls the Bridge contract to mint the equivalent amount of BTC to the user&#x27;s specified address.</li>
</ol>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="522-asset-withdrawal-peg-out">5.2.2. Asset Withdrawal (Peg-out)<a href="#522-asset-withdrawal-peg-out" class="hash-link" aria-label="Direct link to 5.2.2. Asset Withdrawal (Peg-out)" title="Direct link to 5.2.2. Asset Withdrawal (Peg-out)">​</a></h4>
<p>The standard peg-out process is designed for efficiency, relying on Brokers to provide upfront liquidity for a fast user experience:</p>
<ol>
<li><strong>Initiate Burn:</strong> The user initiates a <strong>Burn transaction</strong> to the Bridge contract on the Bitlayer Network. This transaction burns a specific amount of BTC on the L2 and, crucially, includes a <strong>Partially Signed Bitcoin Transaction</strong> (PSBT) which defines the intended L1 withdrawal. The difference between the amount burned on L2 and the amount specified in the PSBT&#x27;s output constitutes the fee for the Broker.</li>
<li><strong>Broker Fronts Funds:</strong> Brokers monitor the Bridge contract for these <strong>Burn transactions</strong>. A Broker who accepts the implied fee can fulfill the request by taking the user&#x27;s provided PSBT, adding their own inputs and signature to complete it, and issuing the final transaction on the Bitcoin network. This mechanism ensures that only one Broker&#x27;s front transaction can be successfully confirmed on-chain.</li>
</ol>
<p>After fronting the funds, the Broker needs to reclaim their capital from the protocol through the security mechanism detailed below.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="53-broker-funds-reclamation">5.3. Broker Funds Reclamation<a href="#53-broker-funds-reclamation" class="hash-link" aria-label="Direct link to 5.3. Broker Funds Reclamation" title="Direct link to 5.3. Broker Funds Reclamation">​</a></h3>
<p>To recover their fronted funds, the Broker initiates a verification process by submitting a <strong>KickOff transaction</strong> to the protocol. This submission serves as an assertion that the Broker has legitimately fulfilled a valid <strong>Burn transaction</strong>. The verification follows the same optimistic, challenge-response game used for state settlement in Chapter 3, where the Broker&#x27;s assertion is assumed correct unless challenged.</p>
<ul>
<li><strong>Challenge Process:</strong> Watchers verify the legitimacy of this Reclaim Claim. If any invalidity is found (e.g., the corresponding <code>Burn</code> transaction does not exist or is invalid), a Watcher will publish a <code>Challenge</code> transaction.</li>
<li><strong>Assertion and Penalty:</strong> Upon being challenged, the Broker must respond within a specified time with an <strong>Assert transaction</strong>, which must contain a <strong>Groth16 ZKP</strong>. If a Watcher can verify that this proof is invalid, they can publish a <strong>Disprove transaction</strong> to penalize the Broker and receive a portion of their bonded collateral as a reward. This game-theoretic process is mechanically identical to the Single Claim Verification Protocol described in Chapter 3.</li>
</ul>
<p>This reclaim verification mechanism relies on the <strong>Bitlayer Light Client</strong> and depends on the Bitcoin mainnet for the finality of Bitlayer Network transactions. Therefore, a <strong>Burn transaction</strong> is considered valid only after it has been included in a Batch and achieved Hard Finality on Bitcoin. If challenged, the Groth16 proof provided by the Broker must contain a complete verification chain from the Bitlayer Network&#x27;s Genesis State to the current state to prove the validity and authenticity of the <strong>Burn transaction</strong>.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="54-escape-hatch">5.4. Escape Hatch<a href="#54-escape-hatch" class="hash-link" aria-label="Direct link to 5.4. Escape Hatch" title="Direct link to 5.4. Escape Hatch">​</a></h3>
<p>The bridge includes an escape hatch to guarantee user sovereignty over their assets, even if the L2 protocol halts. A halt can occur if the Operator repeatedly fails to submit new claims or if a submitted claim is successfully challenged. In this scenario, while the Operator&#x27;s collateral is slashed and the L2 state is protected from further invalid updates, user funds could become locked. The escape hatch provides a new path for withdrawal, which also relies on Brokers for liquidity.</p>
<p>The process unfolds as follows:</p>
<ol>
<li><strong>User-Initiated Forced Withdrawal</strong>: A user initiates an emergency withdrawal by broadcasting a force-inclusion withdrawal transaction directly to the Bitcoin L1. This transaction contains a signature proving ownership of the L2 account and specifies the L1 address for receiving the funds. While this L1 transaction cannot be fully processed by the stalled rollup, it serves as an immutable, on-chain withdrawal request.</li>
<li><strong>Broker Fronts Funds</strong>: Brokers monitor the Bitcoin L1 for these forced withdrawal requests. After aggregating a sufficient number of requests to meet a predefined threshold, a Broker can choose to front the liquidity, sending the funds directly to the users&#x27; specified L1 addresses.</li>
<li><strong>Broker Funds Reclamation</strong>: To reclaim their fronted capital, the Broker submits a reclaim claim to the bridge protocol, accompanied by a single Groth16 proof. This proof must validate three distinct conditions:<!-- -->
<ol>
<li><strong>Proof of L2 Halt</strong>: Evidence that the rollup protocol is stalled. This is confirmed either by showing a CommitBatchTimeout transaction (indicating the Operator&#x27;s failure to submit a new batch) or a successful slash transaction (indicating the last submitted batch was fraudulent).</li>
<li><strong>Proof of Valid User Request</strong>: Evidence that the user&#x27;s withdrawal request is legitimate. This requires proving the existence of the force-inclusion transaction on L1 (via the Bitcoin Light Client) and confirming the user had a sufficient balance in the last correctly finalized L2 state.</li>
<li><strong>Proof of Fulfillment</strong>: Evidence that the Broker has already sent the corresponding funds to the user on L1, also confirmed via the Bitcoin Light Client.</li>
</ol>
</li>
</ol>
<p>This escape hatch mechanism ensures that users always retain control of their assets, relying only on the security of the Bitcoin L1 and the economic incentives of the Broker network. We will explore using account abstraction to define more intelligent withdrawal logic and extending this mechanism to support the emergency withdrawal of assets held within smart contracts.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="6-security-analysis">6. Security Analysis<a href="#6-security-analysis" class="hash-link" aria-label="Direct link to 6. Security Analysis" title="Direct link to 6. Security Analysis">​</a></h2>
<p>This chapter presents a comprehensive analysis of the security that underpins the Bitlayer Rollup. We begin by introducing a general security model for BitVM-style smart contracts, followed by definitions and proofs of their safety and liveness properties. We then conduct a detailed analysis of the Bitcoin settlement security properties discussed in Chapter 3. Finally, we briefly described the inherent censorship resistance provided by decentralized networks.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="61-bitvm-style-smart-contract-security">6.1. BitVM-Style Smart Contract Security<a href="#61-bitvm-style-smart-contract-security" class="hash-link" aria-label="Direct link to 6.1. BitVM-Style Smart Contract Security" title="Direct link to 6.1. BitVM-Style Smart Contract Security">​</a></h3>
<p>BitVM-style smart contracts follow a universal transaction graph structure. In this section, we provide a general security analysis applicable to all BitVM-style contracts, including the Bitlayer settlement protocol.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="611-system-model--assumptions">6.1.1. System Model &amp; Assumptions<a href="#611-system-model--assumptions" class="hash-link" aria-label="Direct link to 6.1.1. System Model &amp; Assumptions" title="Direct link to 6.1.1. System Model &amp; Assumptions">​</a></h4>
<p>In a BitVM-style smart contract, at least three roles are required to collaborate:</p>
<ul>
<li><strong>Transaction Graph Proposer:</strong> The Proposer is responsible for initiating a contract instance. To do so, the Proposer must stake a predefined amount of BTC, serving as both a commitment and collateral against misbehavior.</li>
<li><strong>Attesters:</strong> We assume there are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> Attesters, among whom <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span> are honest. The remaining <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n-m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span> are semi-honest, meaning that they follow the protocol and collaborate to construct the pre-signed signature but may behave unpredictably off-protocol, such as retaining keys after pre-signing, which may allow them to attempt signing additional unauthorized transactions after the pre-signing is completed. Each pre-signing requires the participation of at least <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> Attesters.</li>
<li><strong>Watchers:</strong> Watchers monitor the on-chain state submitted by the Proposer to ensure correctness. If misbehavior is detected, they can issue a <em>Challenge</em> transaction to hold the Proposer accountable by invoking penalties on the staked BTC. The model assumes the existence of at least one rational, honest, and active Watcher.</li>
</ul>
<p>Additionally, we assume a <strong>synchronized network</strong>, where all communications between participants and the Bitcoin network occur within a known bounded time <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Δ</span></span></span></span>. All participants are assumed to be rational and polynomial-time bounded, meaning all cryptographic tools used in the BitVM-style smart contract are secure.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="612-transaction-graph-model">6.1.2. Transaction Graph Model<a href="#612-transaction-graph-model" class="hash-link" aria-label="Direct link to 6.1.2. Transaction Graph Model" title="Direct link to 6.1.2. Transaction Graph Model">​</a></h4>
<p>The transaction graph serves as the backbone of the BitVM-style smart contract, structured as a directed acyclic graph (DAG). This model provides clarity and enforceability to the contract’s execution.</p>
<ul>
<li><strong>Preceding Transactions:</strong> The transactions provide the initial outputs necessary for the contract’s execution, which include the Proposer’s stake reserve and the Watcher’s reserve. The Attesters must validate the existence and correctness of these transactions before pre-signing.</li>
<li><strong>Pre-signed Transactions:</strong> The transactions that Attesters need to pre-sign, which determines the logic of the BitVM-style contract.</li>
<li><strong>Sink Transactions:</strong> The transactions, lacking outgoing edges in the DAG, signify the release of funds.</li>
</ul>
<p><img decoding="async" loading="lazy" alt="Transaction Graph DAG Model" src="/assets/images/dag_model-660ef9aedea3f4b3f0879d4ce5c78f74.png" width="5184" height="2316" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="613-design-principles">6.1.3. Design Principles<a href="#613-design-principles" class="hash-link" aria-label="Direct link to 6.1.3. Design Principles" title="Direct link to 6.1.3. Design Principles">​</a></h4>
<ul>
<li><strong>Stake:</strong> The Proposer must stake a specified amount of BTC to initiate the contract. (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">d</span></span></span></span> BTC in the graph).</li>
<li><strong>Slashable:</strong> Incorrect STF submitted by the Proposer can result in the slashing of their staked BTC.</li>
<li><strong>Termination:</strong> All outputs containing amounts in the pre-signed transactions must have a time lock path (which may involve multiple transactions) leading to Sink transactions, ensuring the contract eventually terminates.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="614-safety">6.1.4. Safety<a href="#614-safety" class="hash-link" aria-label="Direct link to 6.1.4. Safety" title="Direct link to 6.1.4. Safety">​</a></h4>
<p><strong>Safety Goals</strong></p>
<ul>
<li><strong>Validity:</strong> Every transaction in the transaction graph must be valid after pre-signing.</li>
<li><strong>Integrity:</strong> No new transactions can be added to the transaction graph after pre-signing.</li>
<li><strong>Flexibility:</strong> The BitVM-style smart contract can accommodate different security assumptions, depending on the application scenario.</li>
</ul>
<p><strong>Lemma 1</strong>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>t</mi><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>t</mi><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{tx_1, ..., tx_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> be the pre-signed transactions spending <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>t</mi><mi>x</mi><msub><mi>o</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">utxo_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>. No transaction <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo mathvariant="normal">∉</mo><mo stretchy="false">{</mo><mi>t</mi><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>t</mi><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">tx&#x27;\notin\{tx_1, ..., tx_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> can spend <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>t</mi><mi>x</mi><msub><mi>o</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">utxo_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>.</p>
<p><strong>Proof:</strong>
We prove this important lemma by contradiction. Assume a committee <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>a</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>e</mi><msub><mi>r</mi><mn>0</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>a</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>e</mi><msub><mi>r</mi><mrow><mi>n</mi><mo>−</mo><mi>m</mi></mrow></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{attester_0, ..., attester_{n-m}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> performed the pre-signing. If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">tx&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> exists, it indicates that the Attesters have performed additional signing outside of the pre-signing process, which implies that these <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> Attesters are semi-honest. This contradicts the assumption.</p>
<p><strong>Lemma 2</strong>
Each pre-sign committee must include at least one honest Attester.</p>
<p><strong>Theorem 1 (Validity):</strong>
If a valid pre-signed signature <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span></span></span></span> is produced for a transaction <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">tx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">x</span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">tx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">x</span></span></span></span> is valid.</p>
<p><strong>Proof:</strong>
By Lemma 2, at least one honest Attester <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> participated in the pre-signing and contributed partial signature <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">tx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">x</span></span></span></span>. Hence, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">tx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">x</span></span></span></span> received by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> must be valid. Since the validity of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span></span></span></span> relies on all Attesters contributing partial signatures to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">tx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">x</span></span></span></span>, it must be valid.</p>
<p><strong>Theorem 2 (Integrity):</strong></p>
<p><strong>Proof:</strong>
Except for Sink transactions, all outputs must require a multi-signature from the pre-sign committee. By Lemma 1, we can conclude that all participants can only spend the UTXOs in the transaction graph along the predefined path, ensuring the integrity of the BitVM-style smart contract.</p>
<p><strong>Theorem 3 (Flexibility):</strong></p>
<p><strong>Proof:</strong>
We can dynamically adjust the security assumptions of the Attesters based on the requirements of the application scenario, as long as the pre-sign committee ultimately includes at least one honest node. Based on Lemma 1 and Lemma 2, validity and integrity can then be deduced.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="615-liveness">6.1.5 Liveness<a href="#615-liveness" class="hash-link" aria-label="Direct link to 6.1.5 Liveness" title="Direct link to 6.1.5 Liveness">​</a></h4>
<p><strong>Liveness Goal</strong></p>
<ul>
<li><strong>Funds Liquidity:</strong> Funds involved in the contract’s Preceding transactions must not remain indefinitely locked.</li>
</ul>
<p><strong>Theorem 4 (Funds Liquidity):</strong></p>
<p><strong>Proof:</strong>
Since the time lock duration is known and finite, the Termination principle of the transaction graph ensures that all funds will eventually be unlocked and flow to Sink transactions within a finite time.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="62-bitcoin-settlement-security">6.2 Bitcoin Settlement Security<a href="#62-bitcoin-settlement-security" class="hash-link" aria-label="Direct link to 6.2 Bitcoin Settlement Security" title="Direct link to 6.2 Bitcoin Settlement Security">​</a></h3>
<p>This section focuses on proving the Bitcoin settlement security properties introduced in Chapter 3.4.4.</p>
<p><strong>Theorem 5 (Completeness):</strong>
An honest Operator who correctly follows the protocol and submits valid state claims will never be unjustly penalized.</p>
<p><strong>Proof:</strong>
An honest operator publishes valid claims and sub-program results within the required time windows, ensuring no inconsistencies arise. As a result, no watcher can unlock a <em>Disprove Script</em>, and the operator is not penalized. To save space, the details are omitted here.</p>
<p><strong>Theorem 6 (Soundness):</strong>
A dishonest Operator who submits a fraudulent claim cannot avoid being penalized, as an honest Watcher will always be able to construct a valid <em>Disprove</em> transaction.</p>
<p><strong>Proof:</strong>
If the dishonest operator does not publish <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Φ</span></span></span></span> within <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mrow><mi>c</mi><mi>l</mi><mi>a</mi><mi>i</mi><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Delta_{claim}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span><span class="mord mathnormal mtight">aim</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>, the operator will be penalized. During the Claim Phase, the dishonest operator publishes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Φ</span></span></span></span>. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">SNARG.Vrfy</mtext></mrow><annotation encoding="application/x-tex">\texttt{SNARG.Vrfy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.2222em"></span><span class="mord text"><span class="mord texttt">SNARG.Vrfy</span></span></span></span></span> will fail locally for watchers, they raise a challenge within <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mtext>challenge</mtext></msub></mrow><annotation encoding="application/x-tex">\Delta_{\text{challenge}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">challenge</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span>, moving the protocol to the Challenge Phase. If the operator does not publish the result of all sub-programs within time <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mrow><mi>a</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Delta_{assert}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em">sser</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>, the operator will be penalized.</p>
<p>If there is a disproved algorithm allowing watchers to unlock a <em>Disprove Script</em> with inputs and outputs published by the operator that contradict the sub-program execution, then a dishonest operator cannot escape penalties.</p>
<p>We prove the existence of the disprove algorithm as follows. First, since the inputs and outputs published by the operator contradict the local sub-program execution, there must be at least one inconsistent output produced by the sub-program, saying <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>. Then, we check the consistency of the inputs of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>. If all inputs are consistent, we select <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> as the challenged sub-program, otherwise recursively run the first step for one of the inconsistent inputs. So, the disprove algorithm must successfully select a sub-program to challenge.</p>
<p><strong>Theorem 7 (Efficiency):</strong>
The entire claim verification process, whether it results in acceptance or rejection, is guaranteed to terminate within a bounded timeframe defined by the protocol&#x27;s time locks.</p>
<p><strong>Proof:</strong>
Each phase of the protocol has a bounded time. If both the Operator and Watcher are honest in following the protocol, the optimistic time bound is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mrow><mi>c</mi><mi>l</mi><mi>a</mi><mi>i</mi><mi>m</mi></mrow></msub><mo>+</mo><msub><mi mathvariant="normal">Δ</mi><mrow><mi>c</mi><mi>h</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Delta_{claim} + \Delta_{challenge}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span><span class="mord mathnormal mtight">aim</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">ha</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">ll</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">g</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span>. If either the Operator or any Watcher tries to destroy the protocol, the time-bound will become <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mrow><mi>c</mi><mi>l</mi><mi>a</mi><mi>i</mi><mi>m</mi></mrow></msub><mo>+</mo><msub><mi mathvariant="normal">Δ</mi><mrow><mi>a</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>t</mi></mrow></msub><mo>+</mo><msub><mi mathvariant="normal">Δ</mi><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>v</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Delta_{claim} + \Delta_{assert} +\Delta_{disprove}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span><span class="mord mathnormal mtight">aim</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em">sser</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">ro</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span>. Thus, the maximum time bound to confirm is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mrow><mi>c</mi><mi>l</mi><mi>a</mi><mi>i</mi><mi>m</mi></mrow></msub><mo>+</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">{</mo><msub><mi mathvariant="normal">Δ</mi><mrow><mi>c</mi><mi>h</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>e</mi></mrow></msub><mo separator="true">,</mo><msub><mi mathvariant="normal">Δ</mi><mrow><mi>a</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>t</mi></mrow></msub><mo>+</mo><msub><mi mathvariant="normal">Δ</mi><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>v</mi><mi>e</mi></mrow></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Delta_{claim} + \max\{\Delta_{challenge}, \Delta_{assert} + \Delta_{disprove}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span><span class="mord mathnormal mtight">aim</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em"></span><span class="mop">max</span><span class="mopen">{</span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">ha</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">ll</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">g</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em">sser</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">ro</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>, so that the protocol terminates regardless of whether the claim is accepted or rejected. Thus, the protocol guarantees efficiency by design.</p>
<center><img src="/img/Whitepaper/settlement_security.png" alt="Bitcoin Settlement Security"></center>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="63-censorship-resistance">6.3 Censorship Resistance<a href="#63-censorship-resistance" class="hash-link" aria-label="Direct link to 6.3 Censorship Resistance" title="Direct link to 6.3 Censorship Resistance">​</a></h3>
<p>Unlike traditional L2 architectures that rely on a single sequencer, our design employs a rotating manner among validators to produce blocks. This decentralized sequencing mechanism ensures that no single party can unilaterally censor transactions. As block production rotates among validators in a permissionless and stake-weighted manner, any attempt to exclude valid transactions can be bypassed in subsequent blocks, providing strong built-in censorship resistance and enhancing the neutrality of the network.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="7-system-architecture">7. System Architecture<a href="#7-system-architecture" class="hash-link" aria-label="Direct link to 7. System Architecture" title="Direct link to 7. System Architecture">​</a></h2>
<p>A robust and well-engineered system architecture is paramount to achieving Bitlayer&#x27;s dual goals of high performance and trust-minimized security. At the heart of our design is a dual-subsystem model that cleanly decouples the L2&#x27;s high-throughput execution layer from its L1 settlement and security layer. This chapter details this architecture, starting with the core principle of decoupling, followed by a system-level overview of the data flow, and a detailed analysis of the components within both the Validator (Performance) Subsystem and the Rollup (Security) Subsystem.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="71-decoupling-of-l2-execution-and-l1-settlement">7.1 Decoupling of L2 Execution and L1 Settlement<a href="#71-decoupling-of-l2-execution-and-l1-settlement" class="hash-link" aria-label="Direct link to 7.1 Decoupling of L2 Execution and L1 Settlement" title="Direct link to 7.1 Decoupling of L2 Execution and L1 Settlement">​</a></h3>
<p>The core design principle of the Bitlayer architecture is the decoupling of L2 execution from L1 settlement. This strategic partition divides the system&#x27;s functionalities into two distinct domains: a Validator (Performance) Subsystem and a Rollup (Security) Subsystem.</p>
<ul>
<li><strong>The Validator Subsystem</strong>: This subsystem is a high-performance blockchain focused exclusively on processing L2 transactions (including L1 Forced Transactions), including transaction ordering, smart contract execution, and state storage. It is designed for high throughput and low latency to provide users with sub-second soft finality. Its performance depends only on its own consensus and computation technologies, independent of L1 interaction. We therefore refer to this subsystem as the <strong>Performance Domain</strong>, as it is built for high-frequency state computation.</li>
<li><strong>The Rollup Subsystem</strong>: This subsystem anchors the state and security of the Validator Subsystem to the Bitcoin network. It is responsible for all L1 interactions, including state commitments and the fraud-proof challenge-response protocol. Its security guarantees are cryptographically traceable to Bitcoin&#x27;s Proof-of-Work consensus. We therefore refer to this subsystem as the Security Domain, as its purpose is to ensure the integrity of the L1 settlement process.</li>
</ul>
<p>Similar to a microservices architecture, this separation of concerns allows each subsystem to be developed and optimized independently. For example, optimizations to the Validator Subsystem, such as upgrading the consensus engine, can proceed without altering the L1 interaction protocol. Conversely, the Rollup Subsystem can integrate new proving systems without re-architecting the core L2 execution layer. This modular design ensures the system is both robust and adaptable to future technological changes.</p>
<center><p><img decoding="async" loading="lazy" alt="High-level overview of the Dual-Subsystem Architecture." src="/assets/images/system_overview-d56e7e08085a6e0b354bc59416a99c75.png" width="2780" height="2156" class="img_ev3q"></p></center>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="72-the-validator-subsystem">7.2 The Validator Subsystem<a href="#72-the-validator-subsystem" class="hash-link" aria-label="Direct link to 7.2 The Validator Subsystem" title="Direct link to 7.2 The Validator Subsystem">​</a></h3>
<p>The Validator Subsystem is engineered exclusively for performance. Its architecture is composed of three core components: a <strong>Decentralized Sequencer</strong>, a <strong>Parallel Execution Engine</strong>, and a <strong>High-Concurrency Data Store</strong>. These components are integrated via a <strong>proactive computation pipeline</strong>, which collectively constitutes the primary driver of Bitlayer&#x27;s transaction throughput and low-latency characteristics, providing the capacity to support peak loads in the order of tens of thousands of <strong>transactions per second (TPS)</strong>.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="721-decentralized-sequencer">7.2.1 Decentralized Sequencer<a href="#721-decentralized-sequencer" class="hash-link" aria-label="Direct link to 7.2.1 Decentralized Sequencer" title="Direct link to 7.2.1 Decentralized Sequencer">​</a></h4>
<p>The sequencer functions as the ordering and consensus core of the Bitlayer platform. It is implemented as a decentralized network of validators operating under a Proof-of-Stake (PoS) protocol. Its primary design objective is to furnish a trustless, <strong>credibly neutral</strong> mechanism for transaction ordering, thereby mitigating the risks inherent in centralized sequencers, such as single points of failure, malicious transaction reordering (e.g., MEV extraction), and censorship. The sequencer network receives transactions from across the network and utilizes a high-performance BFT consensus protocol to establish a canonical, global ordering for these transactions within a block, which then attains economic-stake-backed <strong>soft finality</strong>.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="722-parallel-execution-engine">7.2.2 Parallel Execution Engine<a href="#722-parallel-execution-engine" class="hash-link" aria-label="Direct link to 7.2.2 Parallel Execution Engine" title="Direct link to 7.2.2 Parallel Execution Engine">​</a></h4>
<p>The execution engine is designed to overcome the performance limitations of the EVM&#x27;s sequential execution model. The principal challenge in parallelizing EVM execution is its interleaved state access pattern, which complicates dependency prediction. Our core innovation is a dependency analysis and state conflict resolution mechanism specifically optimized for this environment. It leverages principles from <strong>Optimistic Concurrency Control</strong>, adapted for the blockchain context. The engine speculatively executes transactions in parallel under the assumption of non-conflict, with coordination mechanisms engaged only upon detection of a data dependency. Advanced techniques, including <strong>operation-level conflict resolution</strong> and <strong>hint-based proactive scheduling</strong>, are employed. This enables the engine to re-execute only the minimal set of conflicting operations, rather than entire transactions, thereby maximizing the utilization of multi-core processor architectures and significantly elevating the transaction processing capacity.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="723-blockchain-native-storage-engine">7.2.3 Blockchain-Native Storage Engine<a href="#723-blockchain-native-storage-engine" class="hash-link" aria-label="Direct link to 7.2.3 Blockchain-Native Storage Engine" title="Direct link to 7.2.3 Blockchain-Native Storage Engine">​</a></h4>
<p>The data store is a high-performance persistence layer tailored to the access patterns of the parallel execution engine. It addresses the bottlenecks of general-purpose databases (e.g., LevelDB/RocksDB), such as state bloat and I/O contention. It is responsible for storing all canonical blockchain data, including the account state, smart contract code, and transaction receipts. Performance is achieved through <strong>asynchronous I/O interfaces</strong> and <strong>batched writes</strong>, which decouple execution from storage latency. Architecturally, it employs <strong>index and key-value (KV) separation</strong> and <strong>semantics-aware data partitioning</strong>. This design minimizes lock contention and reduces write amplification, providing robust storage support for the high-concurrency demands of the parallel execution engine.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="724-the-proactive-computation-pipeline">7.2.4 The Proactive Computation Pipeline<a href="#724-the-proactive-computation-pipeline" class="hash-link" aria-label="Direct link to 7.2.4 The Proactive Computation Pipeline" title="Direct link to 7.2.4 The Proactive Computation Pipeline">​</a></h4>
<p>The Validator Subsystem integrates its components into an asynchronous, multi-stage pipeline that implements a principle of <strong>proactive computation</strong>, analogous to out-of-order execution in modern CPUs. Instead of a rigid, sequential paradigm (<code>Consensus -&gt; Execute -&gt; Persist -&gt; Checkpointing</code>), our pipeline deconstructs these tasks to enable temporal overlapping. This allows the system to work on multiple blocks simultaneously at different stages; for example, the consensus process for ordering transactions in <strong>Block N+1</strong> can run concurrently with the execution of <strong>Block N</strong>. This overlapping of consensus and execution is key to maximizing resource utilization and significantly reducing end-to-end transaction latency.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="73-the-rollup-subsystem">7.3 The Rollup Subsystem<a href="#73-the-rollup-subsystem" class="hash-link" aria-label="Direct link to 7.3 The Rollup Subsystem" title="Direct link to 7.3 The Rollup Subsystem">​</a></h3>
<p>This section details the components that verifiably settle the computational results of the Validator Subsystem on the Bitcoin network, endowing the Bitcoin blockchain with the capability for active state verification and dispute resolution.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="731-recursive-proving-system">7.3.1 Recursive Proving System<a href="#731-recursive-proving-system" class="hash-link" aria-label="Direct link to 7.3.1 Recursive Proving System" title="Direct link to 7.3.1 Recursive Proving System">​</a></h4>
<p>The cryptographic foundation of Bitlayer&#x27;s security is its <strong>Recursive Proving System</strong>. This system, implemented as an asynchronous Zero-Knowledge Proof (ZKP) generator, is tasked with producing a single, succinct, and irrefutable proof of validity for all state transitions within a settlement period. A key design innovation is its complete <strong>decoupling from the L2&#x27;s critical performance path</strong>. Proof generation operates as a background process, ensuring that L2 block production rates and transaction confirmation latencies are independent of the computationally intensive proving process. This architecture facilitates the future development of a permissionless <strong>Proving Market</strong> to further optimize proving efficiency and cost through market-based competition.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="732-engineering-implementation-of-the-l1-finality-protocol">7.3.2 Engineering Implementation of the L1 Finality Protocol<a href="#732-engineering-implementation-of-the-l1-finality-protocol" class="hash-link" aria-label="Direct link to 7.3.2 Engineering Implementation of the L1 Finality Protocol" title="Direct link to 7.3.2 Engineering Implementation of the L1 Finality Protocol">​</a></h4>
<p>The translation of the complex BitVM-based protocol into an automated and robust system represents a core engineering challenge addressed by the Rollup Subsystem. A modular software design maps protocol roles to specific components, ensuring system maintainability, security, and extensibility. The implementation is centered around three primary software entities: the <strong>Operator</strong>, the <strong>Watcher</strong>, and the <strong>Attester</strong>.</p>
<ul>
<li><strong>Operator</strong>: The Operator is the primary agent responsible for advancing the protocol. It is an automated software suite comprising several internal modules:<!-- -->
<ul>
<li><code>Transaction Graph Builder</code>: This module is the core implementation of the BitVM paradigm. It deterministically constructs a complex Bitcoin transaction graph from L2 state batches, in strict adherence to the <code>Transaction Graph Specification</code>. This involves programmatically generating Bitcoin Scripts for all challenge-response pathways and embedding the L2 state root via hash locks.</li>
<li><code>Batch Committer</code>: This module optimizes L1 interaction costs by aggregating state commitments from multiple L2 batches into a single <strong>ClaimTransaction</strong>, thereby amortizing the on-chain footprint.</li>
<li><code>Challenge Responder</code>: This defensive module monitors the L1 for challenges against its commitments. Upon detection, it retrieves the corresponding ZK proof from the Proving System and broadcasts the appropriate response transaction as defined in the specification.</li>
</ul>
</li>
<li><strong>Watcher</strong>: Representing the decentralized security mechanism, the Watcher is software that can be run by any full-node participant to audit the Operator.<!-- -->
<ul>
<li><code>Proof Verifier</code>: This module independently fetches state commitments from L1 and corresponding L2 block data. It re-executes the state transitions to verify the integrity of the Operator&#x27;s submitted state root, serving as the first line of defense against fraud.</li>
<li><code>Challenger</code>: If the <code>Proof Verifier</code> detects a discrepancy, the <code>Challenger</code> module is activated to construct and broadcast a challenge transaction on L1, thereby initiating the on-chain dispute resolution process and contesting the Operator&#x27;s staked collateral.</li>
</ul>
</li>
<li><strong>Attester</strong>: A set of highly-staked validators provide security for the validity of the transaction graph.<!-- -->
<ul>
<li><code>Transaction Graph Validator</code>: Prior to signing, each Attester utilizes this module to independently validate the Operator-constructed transaction graph against the formal specification, ensuring it contains no exploitable or invalid paths.</li>
<li><code>Musig Signer</code>: Upon successful validation, this module employs an advanced multi-signature scheme (e.g., MuSig2) to produce a single, aggregated signature for the transaction graph. This engineering choice provides superior efficiency, privacy, and scalability over traditional <code>CHECKMULTISIG</code> operations.</li>
</ul>
</li>
</ul>
<p>These components interface with the L1 via a <code>Bitcoin Provider</code> module (an RPC wrapper), forming an automated L1 finality system with a clear separation of duties. This modular implementation enhances testability and maintainability while providing a solid foundation for future protocol upgrades.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="74-transaction-lifecycle">7.4 Transaction Lifecycle<a href="#74-transaction-lifecycle" class="hash-link" aria-label="Direct link to 7.4 Transaction Lifecycle" title="Direct link to 7.4 Transaction Lifecycle">​</a></h3>
<center><p><img decoding="async" loading="lazy" alt="Detailed Transaction Lifecycle" src="/assets/images/transaction_lifecycle-c894448fb26fbe0640f92fbde8b70add.png" width="7688" height="3772" class="img_ev3q"></p></center>
<ul>
<li><strong>Sequencing:</strong> Users initiate transactions on the L2 network (Step 1a). These transactions are collected by the Sequencer component within the validator, while on-chain interactions (Step 1b), such as deposits and force inclusion transactions, are submitted to Bitcoin. The <strong>Bitcoin Listener</strong> component continuously monitors the Bitcoin network and synchronizes L1 transactions to the Sequencer.</li>
<li><strong>Block Consensus:</strong> After collecting the transactions, one of the Sequencers is selected to propose a set of transactions. All validators then reach an agreement on the ordering and content of the proposal through the consensus (Step 2). Once consensus is achieved, a sequenced L2 block is produced (Step 3).</li>
<li><strong>Execution:</strong> Once a block is produced, it is immediately executed by the validator. The Executor performs parallel execution of the block&#x27;s transactions to compute the new world state.</li>
<li><strong>Persistency:</strong> The new state is efficiently persisted. At this point, the L2 block achieves <strong>soft finality</strong> (Step 4).</li>
<li><strong>Inter-Subsystem Handoff:</strong> Upon reaching <strong>soft finality</strong> within the validator network, the state data of an L2 block is transmitted to the Rollup Subsystem via the internal asynchronous API. This asynchronous communication is critical for performance isolation, ensuring that the high throughput of the Validator Subsystem remains unencumbered by the proof-generation latency of the Rollup Subsystem (Step 5).</li>
<li><strong>State Claim:</strong> The Operator&#x27;s Batch Committer component <strong>aggregates</strong> multiple block data, assembles rollup batch information, and starts the Bitcoin settlement process as described in Chapter 3 (Step 6).</li>
<li><strong>Challenge Responder:</strong> When a Watcher challenges the state claim posted by the Operator on Bitcoin (Step 7), the Operator responds by generating a zero-knowledge proof (ZKP) to defend the correctness of the claimed state (Step 8). The Prover generates a ZKP based on the execution trace and state transition, which is then <strong>submitted by the Operator</strong> to Bitcoin (Step 9) as evidence supporting the validity of the rollup state.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="75-conclusion">7.5 Conclusion<a href="#75-conclusion" class="hash-link" aria-label="Direct link to 7.5 Conclusion" title="Direct link to 7.5 Conclusion">​</a></h3>
<p>Ultimately, the Bitlayer V2 architecture establishes a clear blueprint for scaling Bitcoin: it leverages Bitcoin as the ultimate decentralized trust and settlement layer, while Bitlayer Network functions as a high-throughput, verifiable computation layer built atop it. This design provides a viable pathway to unlock the vast, dormant capital in the Bitcoin ecosystem, laying a foundational infrastructure for a secure, scalable, and vibrant decentralized finance ecosystem on Bitcoin.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="8-limitations-and-future-directions">8. Limitations and Future Directions<a href="#8-limitations-and-future-directions" class="hash-link" aria-label="Direct link to 8. Limitations and Future Directions" title="Direct link to 8. Limitations and Future Directions">​</a></h2>
<p>This chapter reflects on the current design of the Bitlayer Network, discussing its inherent trade-offs and the promising research avenues they inspire. We first outline the primary limitations of our current protocol and then detail future work aimed at addressing these challenges and further advancing the capabilities of Bitcoin L2s.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="81-limitations">8.1 Limitations<a href="#81-limitations" class="hash-link" aria-label="Direct link to 8.1 Limitations" title="Direct link to 8.1 Limitations">​</a></h3>
<p>While the Bitlayer Network provides a robust framework for a Bitcoin computational layer, its current design involves several trade-offs:</p>
<ol>
<li><strong>Dependency on Validator Set&#x27;s Honesty:</strong> The security of the bridge and settlement protocol currently relies on an honest majority assumption within the active validator set, which serves as the Attesting Committee. While this security is cryptographically enforced, it represents a trust assumption beyond Bitcoin&#x27;s own proof-of-work. Eliminating this reliance on an external honest-majority through future Bitcoin protocol upgrades remains a key goal for achieving a more fully trustless system.</li>
<li><strong>Centralized Operator and Liveness:</strong> The current model uses a single, rotating Rollup Operator for sequencing and settlement. While this is efficient, it presents a potential single point of failure for liveness if the operator goes offline. This motivates the development of a multi-operator mechanism.</li>
<li><strong>Reliance on Broker Liquidity:</strong> The fast withdrawal and emergency escape hatch mechanisms depend on an active network of third-party Brokers to provide upfront liquidity. The system&#x27;s user experience and capital efficiency could be further improved by protocol-native solutions that reduce this reliance.</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="82-future-directions">8.2 Future Directions<a href="#82-future-directions" class="hash-link" aria-label="Direct link to 8.2 Future Directions" title="Direct link to 8.2 Future Directions">​</a></h3>
<p>We are actively researching several enhancements to address these limitations and expand the network&#x27;s capabilities:</p>
<ol>
<li><strong>Leveraging Future Bitcoin Upgrades (Covenants):</strong> Upcoming potential Bitcoin protocol upgrades, such as those introducing new covenant opcodes (e.g., <code>OP_CTV</code> <a href="#ref10">[10]</a>, <code>OP_CAT</code>, or similar proposals), could pave the way for more trustless smart contract functionalities directly on Bitcoin. We are closely monitoring these developments and plan to integrate such features, if and when they become available and stable. This could allow for:<!-- -->
<ul>
<li><strong>Elimination of Attesting Committees:</strong> Potentially removing the need for an attesting committee for certain verification processes, moving towards a more fully trustless model.</li>
<li><strong>Enhanced Permissionlessness:</strong> Reducing reliance on pre-signed transactions or specific roles in the dispute resolution protocol, making the system even more open.</li>
<li><strong>On-Chain Operator Election:</strong> Managing Rollup Operator election and rotation more directly on-chain, further enhancing liveness and decentralization.</li>
<li><strong>Optimized Collateral Management:</strong> Enabling more sophisticated collateral reuse mechanisms within the same epoch without compromising security, thereby reducing the capital costs for operators.</li>
</ul>
</li>
<li><strong>Advanced Proving Systems:</strong> Continuously evaluating and integrating advancements in zero-knowledge proof systems and other cryptographic techniques to improve proof generation efficiency, reduce on-chain verification costs, and enhance overall system performance.</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="9-conclusions">9. Conclusions<a href="#9-conclusions" class="hash-link" aria-label="Direct link to 9. Conclusions" title="Direct link to 9. Conclusions">​</a></h2>
<p>In this paper, we have introduced Bitlayer, a scalable and EVM-compatible computational layer for Bitcoin, whose security is based on an honest majority assumption. Bitlayer is built upon the BitVM paradigm to enable complex, general-purpose computation while anchoring its security directly to the Bitcoin network. Our core contribution is a novel recursive settlement protocol, the first of its kind to allow for the continuous, verifiable settlement of Layer 2 state transitions on Bitcoin. This protocol, combined with a synergistic asset bridge sharing the same security model and a fully EVM-compatible execution layer, creates a complete and practical platform for decentralized applications.</p>
<p>We view Bitlayer as a foundational step towards building the premier infrastructure for the BTCFi ecosystem. By demonstrating a clear architecture where Bitcoin acts as the ultimate settlement layer and Bitlayer as an efficient, verifiable computational layer, our work provides a practical blueprint for unlocking Bitcoin&#x27;s vast potential. We hope that our design, which prioritizes low transaction costs and strong censorship resistance, encourages further research into scalable and secure applications built upon Bitcoin.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="references">References<a href="#references" class="hash-link" aria-label="Direct link to References" title="Direct link to References">​</a></h2>
<p><span id="ref1">1</span>. S. Nakamoto. Bitcoin: A Peer-to-Peer Electronic Cash System, 2009. <a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener noreferrer">https://bitcoin.org/bitcoin.pdf</a>.</p>
<p><span id="ref2">2</span>. Linus, Robin, Lukas Aumayr, Alexei Zamyatin, Andrea Pelosi, Zeta Avarikioti, and Matteo Maffei. BitVM2: Bridging Bitcoin to Second Layers. <a href="https://bitvm.org/bitvm_bridge.pdf" target="_blank" rel="noopener noreferrer">https://bitvm.org/bitvm_bridge.pdf</a></p>
<p><span id="ref3">3</span>. Robin Linus. BitVM: Compute anything on bitcoin, December 2023. <a href="https://bitvm.org/bitvm.pdf" target="_blank" rel="noopener noreferrer">https://bitvm.org/bitvm.pdf</a></p>
<p><span id="ref4">4</span>. J. Groth. On the size of pairing-based non-interactive arguments, 2016. <a href="https://eprint.iacr.org/2016/260.pdf" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2016/260.pdf</a></p>
<p><span id="ref5">5</span>. Dan Boneh and Victor Shoup. A Graduate Course in Applied Cryptography
. <a href="https://toc.cryptobook.us/book.pdf" target="_blank" rel="noopener noreferrer">https://toc.cryptobook.us/book.pdf</a></p>
<p><span id="ref6">6</span>. Bitcoin Wiki. Script, 2025. <a href="https://en.bitcoin.it/wiki/Scrip" target="_blank" rel="noopener noreferrer">https://en.bitcoin.it/wiki/Scrip</a></p>
<p><span id="ref7">7</span>. Kalodner, H., Goldfeder, S., Chen, X., Weinberg, S. M., &amp; Felten, E. W. (2018). Arbitrum: Scalable, private smart contracts. In 27th USENIX Security Symposium (USENIX Security 18). <a href="https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-kalodner.pdf" target="_blank" rel="noopener noreferrer">https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-kalodner.pdf</a></p>
<p><span id="ref8">8</span>. J. Buchmann, E. Dahmen, S. Ereth, A. H¨ulsing, and M. R¨uckert. On the security of the winternitz one-time signature scheme, 2011. <a href="https://eprint.iacr.org/2011/191.pdf" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2011/191.pdf</a></p>
<p><span id="ref9">9</span>. Wood, G. (2014). &quot;Ethereum: A Secure Decentralised Generalised Transaction Ledger.&quot; Ethereum Project Yellow Paper. <a href="https://ethereum.github.io/yellowpaper/paper.pdf" target="_blank" rel="noopener noreferrer">https://ethereum.github.io/yellowpaper/paper.pdf</a></p>
<p><span id="ref10">10</span>. Rubin, J. (2020). &quot;BIP-0119: CHECKTEMPLATEVERIFY.&quot; Bitcoin Improvement Proposals. <a href="https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki" target="_blank" rel="noopener noreferrer">https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki</a></p></div></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/Learn/Bitlayer Rollup/bridge"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Trust-minimized BTC Bridge</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/Learn/Technologies/overview"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Overview</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#abstract" class="table-of-contents__link toc-highlight">Abstract</a></li><li><a href="#1-introduction" class="table-of-contents__link toc-highlight">1. Introduction</a></li><li><a href="#2-network-architecture" class="table-of-contents__link toc-highlight">2. Network Architecture</a><ul><li><a href="#21-network-participants-and-roles" class="table-of-contents__link toc-highlight">2.1. Network Participants and Roles</a></li><li><a href="#22-dual-level-transaction-finality" class="table-of-contents__link toc-highlight">2.2. Dual-Level Transaction Finality</a></li></ul></li><li><a href="#3-settling-l2-state-on-bitcoin" class="table-of-contents__link toc-highlight">3. Settling L2 State on Bitcoin</a><ul><li><a href="#31-defining-the-l2-state-claim" class="table-of-contents__link toc-highlight">3.1. Defining the L2 State Claim</a></li><li><a href="#32-cryptographic-primitives" class="table-of-contents__link toc-highlight">3.2. Cryptographic Primitives</a></li><li><a href="#33-protocol-overview" class="table-of-contents__link toc-highlight">3.3. Protocol Overview</a></li><li><a href="#34-settling-a-single-claim" class="table-of-contents__link toc-highlight">3.4. Settling a Single Claim</a></li><li><a href="#35-settling-a-chain-of-claims" class="table-of-contents__link toc-highlight">3.5. Settling a Chain of Claims</a></li><li><a href="#36-summary" class="table-of-contents__link toc-highlight">3.6. Summary</a></li></ul></li><li><a href="#4-state-transition-function-and-batch-execution" class="table-of-contents__link toc-highlight">4. State Transition Function and Batch Execution</a><ul><li><a href="#41-the-bitlayer-network-stf" class="table-of-contents__link toc-highlight">4.1. The Bitlayer Network STF</a></li><li><a href="#42-proving-pipeline" class="table-of-contents__link toc-highlight">4.2. Proving Pipeline</a></li><li><a href="#43-on-chain-verification-via-bitcoin-script" class="table-of-contents__link toc-highlight">4.3. On-Chain Verification via Bitcoin Script</a></li></ul></li><li><a href="#5-bridging-bitcoin-and-bitlayer-network" class="table-of-contents__link toc-highlight">5. Bridging Bitcoin and Bitlayer Network</a><ul><li><a href="#51-roles" class="table-of-contents__link toc-highlight">5.1. Roles</a></li><li><a href="#52-asset-cross-chain-flow" class="table-of-contents__link toc-highlight">5.2. Asset Cross-Chain Flow</a></li><li><a href="#53-broker-funds-reclamation" class="table-of-contents__link toc-highlight">5.3. Broker Funds Reclamation</a></li><li><a href="#54-escape-hatch" class="table-of-contents__link toc-highlight">5.4. Escape Hatch</a></li></ul></li><li><a href="#6-security-analysis" class="table-of-contents__link toc-highlight">6. Security Analysis</a><ul><li><a href="#61-bitvm-style-smart-contract-security" class="table-of-contents__link toc-highlight">6.1. BitVM-Style Smart Contract Security</a></li><li><a href="#62-bitcoin-settlement-security" class="table-of-contents__link toc-highlight">6.2 Bitcoin Settlement Security</a></li><li><a href="#63-censorship-resistance" class="table-of-contents__link toc-highlight">6.3 Censorship Resistance</a></li></ul></li><li><a href="#7-system-architecture" class="table-of-contents__link toc-highlight">7. System Architecture</a><ul><li><a href="#71-decoupling-of-l2-execution-and-l1-settlement" class="table-of-contents__link toc-highlight">7.1 Decoupling of L2 Execution and L1 Settlement</a></li><li><a href="#72-the-validator-subsystem" class="table-of-contents__link toc-highlight">7.2 The Validator Subsystem</a></li><li><a href="#73-the-rollup-subsystem" class="table-of-contents__link toc-highlight">7.3 The Rollup Subsystem</a></li><li><a href="#74-transaction-lifecycle" class="table-of-contents__link toc-highlight">7.4 Transaction Lifecycle</a></li><li><a href="#75-conclusion" class="table-of-contents__link toc-highlight">7.5 Conclusion</a></li></ul></li><li><a href="#8-limitations-and-future-directions" class="table-of-contents__link toc-highlight">8. Limitations and Future Directions</a><ul><li><a href="#81-limitations" class="table-of-contents__link toc-highlight">8.1 Limitations</a></li><li><a href="#82-future-directions" class="table-of-contents__link toc-highlight">8.2 Future Directions</a></li></ul></li><li><a href="#9-conclusions" class="table-of-contents__link toc-highlight">9. Conclusions</a></li><li><a href="#references" class="table-of-contents__link toc-highlight">References</a></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/Learn/Introduction">Learn</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/Build/GettingStarted/QuickStart">Build</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://t.me/bitlayerofficial" target="_blank" rel="noopener noreferrer" class="footer__link-item">Telegram<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discord.com/invite/bitlayer" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://x.com/BitLayerLabs" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://medium.com/@Bitlayer" target="_blank" rel="noopener noreferrer" class="footer__link-item">Blog<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://github.com/bitlayer-org" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Bitlayer</div></div></div></footer></div>
</body>
</html>