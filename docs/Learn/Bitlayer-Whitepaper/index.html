<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Learn/Bitlayer-Whitepaper" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">Bitlayer Network: The Computational Layer for Bitcoin | Bitlayer</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://docs.bitlayer.org/docs/Learn/Bitlayer-Whitepaper"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Bitlayer Network: The Computational Layer for Bitcoin | Bitlayer"><meta data-rh="true" name="description" content="2.0 Preview"><meta data-rh="true" property="og:description" content="2.0 Preview"><link data-rh="true" rel="icon" href="/img/bitlayer.ico"><link data-rh="true" rel="canonical" href="https://docs.bitlayer.org/docs/Learn/Bitlayer-Whitepaper"><link data-rh="true" rel="alternate" href="https://docs.bitlayer.org/docs/Learn/Bitlayer-Whitepaper" hreflang="en"><link data-rh="true" rel="alternate" href="https://docs.bitlayer.org/docs/Learn/Bitlayer-Whitepaper" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Bitlayer Network Whitepaper","item":"https://docs.bitlayer.org/docs/Learn/Bitlayer-Whitepaper"}]}</script><link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3DF3TS5JQ"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-R3DF3TS5JQ",{anonymize_ip:!0})</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.c5284178.css">
<script src="/assets/js/runtime~main.2df82b94.js" defer="defer"></script>
<script src="/assets/js/main.0148b796.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/Bitlayer_docs.svg" alt="Bitlayer Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/Bitlayer_docs.svg" alt="Bitlayer Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Bitlayer</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/Learn/Introduction">Learn@Bitlayer</a><a class="navbar__item navbar__link" href="/docs/Build/GettingStarted/QuickStart">Build@Bitlayer</a><a class="navbar__item navbar__link" href="/docs/BitVMBridge/Concepts/overview">BitVM Bridge</a><a class="navbar__item navbar__link" href="/docs/YBTCFamily/bl_btc_overview">YBTC Family</a><a href="https://blog.bitlayer.org/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://www.bitlayer.org/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Bitlayer<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><a href="https://github.com/bitlayer-org" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input" value=""><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" href="/docs/Learn/Introduction/">Introduction</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Introduction/">Welcome to Bitlayer Documentation</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" tabindex="0" href="/docs/Learn/Introduction/BTRToken/en">BTR Token</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Introduction/BTRToken/en">BTR Token Overview</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Introduction/BTRToken/zh">BTR 代币简介</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Introduction/Roadmap">Roadmap</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" href="/docs/Learn/Bitlayer PoS/Overview">Bitlayer PoS (V1)</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/Overview">Overview</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/AboutGas">About Gas</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/Networks">Network</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/Bridges">Bridges</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/POR">Proof of Reserve</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/Json-RPC">JSON-RPC</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/Contracts">Utility Contracts</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/PegTokens">Peg Tokens</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/BitlayerVsEth">Bitlayer VS. Ethereum</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer PoS/AboutFinality">About finality</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" href="/docs/Learn/Bitlayer Rollup/overview">Bitlayer Rollup (V2)</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer Rollup/overview">Overview</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer Rollup/system-design">System Design</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Bitlayer Rollup/bridge">Trust-minimized BTC Bridge</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/Learn/Bitlayer-Whitepaper">Bitlayer Network Whitepaper</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" href="/docs/Learn/Technologies/overview">Technologies</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Technologies/overview">Overview</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Technologies/bitvm-smart-contract">BitVM-Style Smart Contract</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Technologies/fraud-proofs-on-bitcoin">Fraud Proofs on Bitcoin</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Learn/Technologies/zero-knowledge-on-bitcoin">Zero-Knowledge Proofs on Bitcoin</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/Learn/FAQs/Frequently-asked-questions">MISC</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/Learn/Terms/BTCFi/Desyn/user-agreement">Terms</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">Bitlayer Network Whitepaper</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Bitlayer Network: The Computational Layer for Bitcoin</h1></header>
<center>2.0 Preview</center>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="abstract">Abstract<a href="#abstract" class="hash-link" aria-label="Direct link to Abstract" title="Direct link to Abstract">​</a></h2>
<p>Bitcoin&#x27;s limited transaction throughput and programmability hinder its potential in Decentralized Finance (DeFi). Existing Layer 2 solutions often introduce new trust assumptions, failing to anchor their security directly to Bitcoin&#x27;s consensus. This paper introduces Bitlayer, a Layer 2 network that solves this challenge using the BitVM paradigm. Our core contribution is a novel, recursive verification protocol that, for the first time, enables a continuous chain of Layer 2 state transitions to be verifiably settled on Bitcoin. This moves beyond mere data inscription to achieve security rooted in Bitcoin&#x27;s proof-of-work. Furthermore, we deeply integrate BitVM bridge with our rollup protocol to enable secure transfers of Bitcoin assets. Finally, we designed a high-performance execution engine and a fast consensus mechanism to provide users with &quot;sub-second soft finality. Bitlayer unlocks Bitcoin&#x27;s vast, untapped capital for a new generation of decentralized applications, laying a foundational infrastructure for the Bitcoin DeFi ecosystem.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-introduction">1. Introduction<a href="#1-introduction" class="hash-link" aria-label="Direct link to 1. Introduction" title="Direct link to 1. Introduction">​</a></h2>
<p>Bitcoin holds immense potential for Decentralized Finance (DeFi), but its core design limits transaction throughput and programmability. Activating Bitcoin&#x27;s vast, untapped capital thus depends on secure and scalable Layer 2 solutions <a href="#ref1">[1]</a>.</p>
<p>However, existing approaches to scaling Bitcoin fall short. Sidechains that rely on federated multisignatures introduce centralized trust, fundamentally undermining Bitcoin&#x27;s security model. Meanwhile, early rollup designs for Bitcoin can post transaction data to the L1 but lack a mechanism to enforce the validity of state transitions on-chain. This leaves them vulnerable, as their security is not fully guaranteed by Bitcoin&#x27;s consensus <a href="#ref7">[7]</a>.</p>
<p>This raises a critical question: is it possible to build a Bitcoin L2 that achieves scalable computation while ensuring state validity is enforced by the Bitcoin mainnet itself, without new trust assumptions?</p>
<p>This paper introduces Bitlayer, a Layer 2 network that provides an affirmative answer through rollup architecture and the BitVM paradigm <a href="#ref2">[2]</a>. overcome the limitations of both the Bitcoin and existing Layer 2 solutions by enabling scalable computation while anchoring its security to the underlying Bitcoin blockchain.Our primary contributions are as follows:</p>
<ul>
<li><strong>A Recursive Bitcoin Settlement Protocol for Rollups</strong>: We design and formalize the first rollup protocol that uses a recursive BitVM-based framework to settle a continuous claim chain of Layer 2 state transitions on Bitcoin. This provides security by anchoring the L2&#x27;s validity directly to the L1.</li>
<li><strong>A Synergistic Integration of Bridge and Rollup</strong>: We design and implement a secure asset bridge inspired by the BitVM bridge architecture. The core innovation is its deep integration with our rollup protocol, which ensures that asset security and rollup validity are governed by a unified trust model, enabling seamless and secure asset transfers.</li>
<li><strong>A High-Performance Execution Layer</strong>: We design and implement a high-performance execution layer, powered by a fast consensus mechanism, to achieve Sub-Second Soft Finality. This provides a highly responsive experience ideal for DeFi, gaming, and other demanding applications.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-network-architecture">2. Network Architecture<a href="#2-network-architecture" class="hash-link" aria-label="Direct link to 2. Network Architecture" title="Direct link to 2. Network Architecture">​</a></h2>
<p>Bitlayer operates on a dual-level architecture that combines a Proof-of-Stake (PoS) consensus for fast block production with a rollup framework that anchors its security to the Bitcoin network. The PoS layer allows validators to sequence transactions and produce blocks rapidly, providing a high-throughput, EVM-compatible environment. The rollup layer then periodically commits and settles the state of this L2 chain onto the Bitcoin blockchain. This design leverages Bitcoin as the ultimate layer for security and data availability, while Bitlayer network serves as a scalable and efficient computational layer.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="21-network-participants-and-roles">2.1. Network Participants and Roles<a href="#21-network-participants-and-roles" class="hash-link" aria-label="Direct link to 2.1. Network Participants and Roles" title="Direct link to 2.1. Network Participants and Roles">​</a></h3>
<p>The network is maintained by two key participants: Validators, and Full Nodes.</p>
<ul>
<li><strong>Validators</strong>: Validators form the backbone of the PoS consensus. They are responsible for producing and validating L2 blocks, ensuring the network&#x27;s safety and liveness. To join the validator set, a candidate must stake BTR tokens, and their influence in the consensus is proportional to their total stake, which can include tokens delegated by other BTR holders.<!-- -->
<ul>
<li><strong>Rollup Operator</strong>: The Rollup Operator is a specialized, rotating role assigned to a single validator from the set. This operator is responsible for bundling L2 state transitions into batches, generating cryptographic proofs, and submitting them for settlement on the Bitcoin L1. To ensure accountability and disincentivize fraud, the operator must lock a significant amount of BTC as collateral on L1. The operator role rotates periodically to prevent censorship and centralization.</li>
</ul>
</li>
<li><strong>Full Nodes</strong>: Full nodes maintain a complete copy of the Bitlayer network blockchain, independently verifying all transactions and state transitions without trusting validators. They play a crucial role in enforcing the protocol rules and ensuring network transparency.</li>
</ul>
<center><p><img decoding="async" loading="lazy" alt="Network Architecture" src="/assets/images/001-af43cd50e74f3b1875115855ec8585cd.png" width="697" height="458" class="img_ev3q"></p></center>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="22-dual-level-transaction-finality">2.2. Dual-Level Transaction Finality<a href="#22-dual-level-transaction-finality" class="hash-link" aria-label="Direct link to 2.2. Dual-Level Transaction Finality" title="Direct link to 2.2. Dual-Level Transaction Finality">​</a></h3>
<p>Bitlayer offers a dual-level finality model, giving users and applications a choice between speed and Bitcoin-level security.</p>
<ul>
<li><strong>Soft Finality</strong>: A transaction achieves soft finality in seconds once its containing block is confirmed by Bitlayer&#x27;s PoS consensus. This provides a fast and responsive user experience, with security backed by the economic stake of the validator set.</li>
<li><strong>Hard Finality</strong>: Hard finality is the highest security guarantee, achieved when the L2 state containing the transaction is settled and finalized on the Bitcoin blockchain. Due to the optimistic rollup&#x27;s challenge period, this takes approximately seven days. The security for hard finality relies on only a single honest party to challenge fraud, making it nearly equivalent to Bitcoin&#x27;s own security.</li>
</ul>
<p>In the rare event of a successful L1 challenge that creates a discrepancy between the L2 state and the settled L1 state, the protocol is designed to halt. The network&#x27;s recovery would then be guided by social consensus among stakeholders to ensure the integrity of user assets.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="3-settling-l2-state-on-bitcoin">3. Settling L2 State on Bitcoin<a href="#3-settling-l2-state-on-bitcoin" class="hash-link" aria-label="Direct link to 3. Settling L2 State on Bitcoin" title="Direct link to 3. Settling L2 State on Bitcoin">​</a></h2>
<p>As a Layer 2 rollup, Bitlayer derives its security from Bitcoin. This chapter details the core mechanism that underpins this relationship: settlement. Settlement is the process by which L2 state transitions, executed in Bitlayer&#x27;s high-throughput environment, are committed to and finalized on the Bitcoin L1. This allows Bitlayer to inherit Bitcoin&#x27;s security guarantees. The challenge, however, is achieving this on Bitcoin&#x27;s constrained, non-Turing-complete script environment.</p>
<p>Our solution is a novel settlement protocol inspired by the BitVM paradigm. This chapter systematically deconstructs this protocol. We first define the concepts of a state claim and explain our hybrid verification approach. After introducing the necessary cryptographic primitives, we detail the protocol for settling a single state claim. Finally, we show how this is extended into a recursive protocol that settles a continuous chain of L2 claims, forming the backbone of the entire rollup.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="31-defining-the-l2-state-claim">3.1. Defining the L2 State Claim<a href="#31-defining-the-l2-state-claim" class="hash-link" aria-label="Direct link to 3.1. Defining the L2 State Claim" title="Direct link to 3.1. Defining the L2 State Claim">​</a></h3>
<p>At its core, a blockchain is defined by a <strong>State Transition Function (STF)</strong>, denoted as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Υ</mi></mrow><annotation encoding="application/x-tex">\Upsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Υ</span></span></span></span>. This deterministic function dictates how the network&#x27;s <strong>State (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">s</span></span></span></span>)</strong> evolves. A state, which includes all account balances and contract data, is represented by a 32-byte Merkle root. The STF takes the current state <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">s_{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> and a batch of L2 <strong>Transaction Batch (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">T</span></span></span></span>)</strong> to produce the next state <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">s_{t+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span></span></span></span>:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>s</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi mathvariant="normal">Υ</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>t</mi></msub><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s_{t+1} = \Upsilon(s_t, T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">Υ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mclose">)</span></span></span></span></span>
<p>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span></span></span></span> is the index of transaction batch. The entire history of the blockchain unfolds from an initial <strong>genesis state (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>)</strong>.</p>
<p>A <strong>State Claim (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Φ</span></span></span></span>)</strong> is a formal assertion submitted by a Rollup Operator to a smart contract on the Bitcoin L1. Its purpose is to commit to a new L2 state that has resulted from processing a specific transaction batch. This claim acts as the anchor, linking L2 activity to the L1 and enabling Bitlayer network to inherit Bitcoin&#x27;s security.</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>s</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>s</mi><mi>t</mi></msub><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Phi = \{s_{t-1}, s_t, T\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Φ</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mclose">}</span></span></span></span></span>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="32-cryptographic-primitives">3.2. Cryptographic Primitives<a href="#32-cryptographic-primitives" class="hash-link" aria-label="Direct link to 3.2. Cryptographic Primitives" title="Direct link to 3.2. Cryptographic Primitives">​</a></h3>
<p>The settlement protocol relies heavily on two advanced cryptographic primitives: Succinct Non-interactive Arguments (SNARGs) and Hash-based One-Time Signature scheme.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="321-groth16-snarg">3.2.1. Groth16 SNARG<a href="#321-groth16-snarg" class="hash-link" aria-label="Direct link to 3.2.1. Groth16 SNARG" title="Direct link to 3.2.1. Groth16 SNARG">​</a></h4>
<p>Following the Groth16 paper <a href="#ref4">[4]</a>, a SNARG for a relation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.00773em">R</span></span></span></span> consists of three probabilistic polynomial-time algorithms <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext mathvariant="monospace">Setup</mtext><mo separator="true">,</mo><mtext mathvariant="monospace">Prove</mtext><mo separator="true">,</mo><mtext mathvariant="monospace">Vfy</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\texttt{Setup}, \texttt{Prove}, \texttt{Vfy})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord text"><span class="mord texttt">Setup</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord text"><span class="mord texttt">Prove</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord text"><span class="mord texttt">Vfy</span></span><span class="mclose">)</span></span></span></span>:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>←</mo><mtext mathvariant="monospace">SNARG.Setup</mtext><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta \leftarrow \texttt{SNARG.Setup}(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord texttt">SNARG.Setup</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mclose">)</span></span></span></span>: A setup algorithm that produces a common reference string <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span></span></span></span> for a given relation.</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>←</mo><mtext mathvariant="monospace">SNARG.Prove</mtext><mo stretchy="false">(</mo><mi>R</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><mi mathvariant="normal">Φ</mi><mo separator="true">,</mo><mi>ω</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi \leftarrow \texttt{SNARG.Prove}(R, \delta, \Phi, \omega)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">π</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord texttt">SNARG.Prove</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">Φ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">ω</span><span class="mclose">)</span></span></span></span>: A prover algorithm that, given the common reference string <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span></span></span></span>, a claim <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Φ</span></span></span></span>, and a witness <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">ω</span></span></span></span>, generates a proof argument <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">π</span></span></span></span>.</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn><mo>←</mo><mtext mathvariant="monospace">SNARG.Vfy</mtext><mo stretchy="false">(</mo><mi>R</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><mi mathvariant="normal">Φ</mi><mo separator="true">,</mo><mi>π</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">0/1 \leftarrow \texttt{SNARG.Vfy}(R, \delta, \Phi, \pi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">0/1</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord texttt">SNARG.Vfy</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">Φ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">π</span><span class="mclose">)</span></span></span></span>: A verification algorithm that accepts or rejects the proof.</li>
</ul>
<p>The SNARG satisfies perfect completeness, computational soundness, and what we define as full succinctness.</p>
<p><strong>Definition 3.1 (Full Succinctness):</strong> A protocol <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext mathvariant="monospace">Setup</mtext><mo separator="true">,</mo><mtext mathvariant="monospace">Prove</mtext><mo separator="true">,</mo><mtext mathvariant="monospace">Vfy</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\texttt{Setup}, \texttt{Prove}, \texttt{Vfy})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord text"><span class="mord texttt">Setup</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord text"><span class="mord texttt">Prove</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord text"><span class="mord texttt">Vfy</span></span><span class="mclose">)</span></span></span></span> is fully succinct if the verifier <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Vfy</mtext></mrow><annotation encoding="application/x-tex">\texttt{Vfy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.2222em"></span><span class="mord text"><span class="mord texttt">Vfy</span></span></span></span></span> runs in time polynomial in the security parameter <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">λ</span></span></span></span>, and the size of the proof <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">π</span></span></span></span> is also polynomial in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">λ</span></span></span></span>.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="322-hash-based-one-time-signature-hots">3.2.2. Hash-based One-Time Signature (HOTS)<a href="#322-hash-based-one-time-signature-hots" class="hash-link" aria-label="Direct link to 3.2.2. Hash-based One-Time Signature (HOTS)" title="Direct link to 3.2.2. Hash-based One-Time Signature (HOTS)">​</a></h4>
<p>The Bitcoin script language, with its <code>OP_CHECKSIG</code> opcode <a href="#ref6">[6]</a>, is designed to verify signatures for transactions, not for arbitrary off-chain messages. While proposals like BIP348 exist to extend this functionality, they require a network consensus change. To overcome this limitation, We utilize a Hash-based One-Time Signature scheme (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">HOTS</mtext></mrow><annotation encoding="application/x-tex">\texttt{HOTS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6111em"></span><span class="mord text"><span class="mord texttt">HOTS</span></span></span></span></span>) <a href="#ref5">[5]</a><a href="#ref8">[8]</a>. This approach is particularly advantageous as hash functions are native and computationally inexpensive operations within Bitcoin script.</p>
<p>Our variant of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">HOTS</mtext></mrow><annotation encoding="application/x-tex">\texttt{HOTS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6111em"></span><span class="mord text"><span class="mord texttt">HOTS</span></span></span></span></span> consists of four algorithms:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mi>k</mi><mo separator="true">,</mo><mi>p</mi><mi>k</mi><mo stretchy="false">)</mo><mo>←</mo><mtext mathvariant="monospace">HOTS.setup</mtext><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(sk, pk) \leftarrow \texttt{HOTS.setup}(\lambda)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord texttt">HOTS.setup</span></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mclose">)</span></span></span></span>: Generates a secret key and public key pair from a security parameter.</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">s</mtext><mo>←</mo><mtext mathvariant="monospace">HOTS.publish</mtext><mo stretchy="false">(</mo><mi>p</mi><mi>k</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\texttt{s} \leftarrow \texttt{HOTS.publish}(pk, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord text"><span class="mord texttt">s</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord texttt">HOTS.publish</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>: Publishes a commitment to the Bitcoin script, preparing it to verify a signature for a message of length <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">b</span></span></span></span>.</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">w</mtext><mo>←</mo><mtext mathvariant="monospace">HOTS.sign</mtext><mo stretchy="false">(</mo><mi>s</mi><mi>k</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\texttt{w} \leftarrow \texttt{HOTS.sign}(sk, m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord text"><span class="mord texttt">w</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord texttt">HOTS.sign</span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>: Signs a message <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span> with the secret key to produce a witness <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">w</mtext></mrow><annotation encoding="application/x-tex">\texttt{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord text"><span class="mord texttt">w</span></span></span></span></span>.</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>←</mo><mtext mathvariant="monospace">HOTS.verify</mtext><mo stretchy="false">(</mo><mi>p</mi><mi>k</mi><mo separator="true">,</mo><mtext mathvariant="monospace">w</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0/1, m) \leftarrow \texttt{HOTS.verify}(pk, \texttt{w})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0/1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord texttt">HOTS.verify</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord text"><span class="mord texttt">w</span></span><span class="mclose">)</span></span></span></span>: Verifies the witness <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">w</mtext></mrow><annotation encoding="application/x-tex">\texttt{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord text"><span class="mord texttt">w</span></span></span></span></span>. If valid, it returns <code>1</code> and reveals the original message <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span> on the stack for further on-chain processing.</li>
</ul>
<p>This final property—the on-chain revelation of the signed message—is a critical component for linking consecutive state claims, as will be detailed in Section 3.5.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="33-protocol-overview">3.3. Protocol Overview<a href="#33-protocol-overview" class="hash-link" aria-label="Direct link to 3.3. Protocol Overview" title="Direct link to 3.3. Protocol Overview">​</a></h3>
<p>The entire settlement protocol is embodied in a BitVM-style smart contract, which is not a single, monolithic contract but rather a complex graph of pre-signed Bitcoin transactions. Participants must jointly pre-sign this transaction graph and are bound to interact strictly according to its predefined pathways. Whereas the original BitVM protocol focused on settling claims about events on both external chain and the Bitcoin for bridging purposes, Bitlayer&#x27;s protocol is more intricate. It must settle a continuous <em>sequence</em> of claims, each representing a discrete change in the L2 state, and guarantee that this sequence is consecutive and unbroken.</p>
<p>The protocol can be conceptualized as a recursive structure. In Section 3.4, we will first elaborate on the sub-protocol for settling a single state claim. Then, in Section 3.5, we will detail how this single-claim verification mechanism is recursively embedded within a broader protocol that settles a continuous chain of claims. By combining these two components, we construct the complete rollup protocol for settling the Bitlayer network state on Bitcoin.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="34-settling-a-single-claim">3.4. Settling a Single Claim<a href="#34-settling-a-single-claim" class="hash-link" aria-label="Direct link to 3.4. Settling a Single Claim" title="Direct link to 3.4. Settling a Single Claim">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="341-the-bitvm2-paradigm">3.4.1. The BitVM2 Paradigm<a href="#341-the-bitvm2-paradigm" class="hash-link" aria-label="Direct link to 3.4.1. The BitVM2 Paradigm" title="Direct link to 3.4.1. The BitVM2 Paradigm">​</a></h4>
<p>The on-chain verification of a claim is conducted optimistically. The verifier program in our case is expressed in Bitcoin script. However, as demonstrated by the groundbreaking work of the BitVM Alliance on a Groth16 verifier, a monolithic implementation of such a verifier is far too large to execute directly within a single Bitcoin transaction. Therefore, the BitVM2 paradigm splits the large verifier program into a chain of smaller sub-programs, or &quot;chunks.&quot; The protocol then proceeds as a fraud-proof game, where it is assumed the operator&#x27;s claim is correct unless a challenger can pinpoint an incorrect computation step between two specific chunks.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="342-protocol-roles">3.4.2. Protocol Roles<a href="#342-protocol-roles" class="hash-link" aria-label="Direct link to 3.4.2. Protocol Roles" title="Direct link to 3.4.2. Protocol Roles">​</a></h4>
<p>The BitVM smart contract for claim settlement involves a well-defined set of participants:</p>
<ol>
<li><strong>Attesting Committee:</strong> Rather than forming a new entity, the existing validator set of the Bitlayer network serves as the attesting committee. This committee is collectively responsible for pre-signing the transaction graph that defines the protocol.</li>
<li><strong>Protocol Participants:</strong> The active participants in the settlement game include a single, designated <strong>Operator</strong> responsible for submitting claims and any number of <strong>Watchers</strong>. Watchers can be anyone, including other validators, and their role is to monitor the operator and challenge fraudulent claims.</li>
</ol>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="343-single-claim-verification-protocol">3.4.3. Single Claim Verification Protocol<a href="#343-single-claim-verification-protocol" class="hash-link" aria-label="Direct link to 3.4.3. Single Claim Verification Protocol" title="Direct link to 3.4.3. Single Claim Verification Protocol">​</a></h4>
<p>The protocol for verifying a single claim unfolds as a timed challenge-response game governed by Bitcoin time locks. It ensures that both the Operator and any Watcher must act within specified time bounds or face penalties. The protocol can be broken down into three primary stages, which correspond to a series of interconnected Bitcoin transactions pre-signed by the Attesting Committee.</p>
<p><img decoding="async" loading="lazy" alt="image" src="/assets/images/002-a882c52af99a0529f30d0bcc81c78e86.png" width="1122" height="511" class="img_ev3q"></p>
<p><strong>1. Setup Stage</strong>
Before the game begins, a trusted public setup generates the necessary scripts. The STF (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Υ</mi></mrow><annotation encoding="application/x-tex">\Upsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Υ</span></span></span></span>) is used to create a common reference string <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span></span></span></span> via <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">SNARG.Setup</mtext></mrow><annotation encoding="application/x-tex">\texttt{SNARG.Setup}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.2222em"></span><span class="mord text"><span class="mord texttt">SNARG.Setup</span></span></span></span></span>. The verifier program <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">)</mo><mo>=</mo><mtext mathvariant="monospace">SNARG.Vfy</mtext><mo stretchy="false">(</mo><mi>R</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><mi mathvariant="normal">Φ</mi><mo separator="true">,</mo><mi>π</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(\pi) = \texttt{SNARG.Vfy}(R, \delta, \Phi, \pi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em">π</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord texttt">SNARG.Vfy</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">Φ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">π</span><span class="mclose">)</span></span></span></span> is split into a set of smaller sub-programs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>f</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>I</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{f_i(I_i)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)}</span></span></span></span>. Three types of locking scripts are created: a <code>Claim Script</code> to initiate the process, an <code>Assert Script</code> for the Operator to post results of all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>, and a set of <code>Disprove Scripts</code>, one for each sub-program, which Watchers can use to prove fraud. The Claim Script and Assert Script are composed of multiple HOTS, which force operator to post signed claim and results of all sub-programs. The Disprove Scripts include all sub-programs and are organized within a Taproot address. These scripts are then embedded into the outputs of the pre-signed transaction graph.</p>
<p><strong>2. Claim Stage</strong>
The Operator initiates the process by publishing a <em>Claim</em> transaction, which spends from a previous UTXO and locks their collateral (e.g., <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">d</span></span></span></span> BTC). To unlock this input, the Operator must use their HOTS key to sign and reveal the state claim <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\Phi_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>. This action starts a timer, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mtext>challenge</mtext></msub></mrow><annotation encoding="application/x-tex">\Delta_{\text{challenge}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">challenge</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span>. Watchers observe this claim and can run the STF locally. If they find the claim to be invalid, they can issue a <em>Challenge</em> transaction before the timeout. If no challenge occurs, the Operator reclaims their collateral via an <em>Optimistic Acceptance</em> transaction, and the claim is considered settled.</p>
<p><strong>3. Challenge and Resolution Stage</strong>
If a Watcher issues a <em>Challenge</em> transaction (which may require them to post a smaller collateral, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">c</span></span></span></span> BTC, to deter frivolous challenges), the pessimistic path is taken. The Operator is now compelled to execute an <em>Assert</em> transaction. In doing so, they must run the chunked verifier program locally and use their HOTS key to sign and publish the results of <em>all</em> sub-programs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>f</mi><mi>i</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{f_i\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>. This action starts another timer, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mtext>disprove</mtext></msub></mrow><annotation encoding="application/x-tex">\Delta_{\text{disprove}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">disprove</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span>.</p>
<p>The Watcher now examines the sequence of results published by the Operator. If the Watcher can find a single sub-program <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> where the Operator&#x27;s published output is inconsistent with the execution of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> on the Operator&#x27;s published inputs, they have found fraud. The Watcher can then construct a <em>Disprove</em> transaction. This transaction spends the output corresponding to the fraudulent sub-program, executing that small chunk of logic on-chain to prove the inconsistency. A successful <em>Disprove</em> transaction forfeits the Operator&#x27;s collateral, a portion of which (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">a</span></span></span></span> BTC, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&gt;</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a &gt; c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">c</span></span></span></span>) is awarded to the Watcher. If the Operator correctly publishes results of all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>, or if the Watcher fails to submit a valid <em>Disprove</em> transaction in time, the Operator can finalize the claim via an <em>Acceptance</em> transaction and recover their collateral.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="344-security-properties">3.4.4. Security Properties<a href="#344-security-properties" class="hash-link" aria-label="Direct link to 3.4.4. Security Properties" title="Direct link to 3.4.4. Security Properties">​</a></h4>
<p>This protocol is designed to be secure under the assumption of at least one honest Watcher. Its security rests on three key properties, which are analyzed in detail in Chapter 6.2.</p>
<ul>
<li><strong>Completeness:</strong> An honest Operator who correctly follows the protocol and submits valid state claims will never be unjustly penalized.</li>
<li><strong>Soundness:</strong> A dishonest Operator who submits a fraudulent claim cannot avoid being penalized, as an honest Watcher will always be able to construct a valid <em>Disprove</em> transaction.</li>
<li><strong>Efficiency:</strong> The entire claim verification process, whether it results in acceptance or rejection, is guaranteed to terminate within a bounded timeframe defined by the protocol&#x27;s time locks.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="35-settling-a-chain-of-claims">3.5. Settling a Chain of Claims<a href="#35-settling-a-chain-of-claims" class="hash-link" aria-label="Direct link to 3.5. Settling a Chain of Claims" title="Direct link to 3.5. Settling a Chain of Claims">​</a></h3>
<p>The protocol described above is sufficient for settling a single, isolated claim. However, a rollup requires the continuous settlement of a sequence of claims that represents the ongoing evolution of the L2 state. This is achieved by extending the protocol to recursively chain claims together.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="351-linking-claims-with-hots">3.5.1. Linking Claims with HOTS<a href="#351-linking-claims-with-hots" class="hash-link" aria-label="Direct link to 3.5.1. Linking Claims with HOTS" title="Direct link to 3.5.1. Linking Claims with HOTS">​</a></h4>
<p>The key to chaining claims lies in the transaction graph&#x27;s structure. Each <em>Claim</em> transaction, in addition to its other outputs, creates a special UTXO called a <strong>claim connector</strong>. To submit the next claim (Claim <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span>), the Operator must spend the claim connector UTXO created by the transaction for Claim <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span>. The locking script for this connector requires the Operator to use their HOTS key to sign and reveal the data package for Claim <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span>. This design naturally links adjacent claims into a chronological and unforgeable chain, as each claim transaction can only be created by consuming an output from its direct predecessor. Bitcoin time locks are used to enforce a regular cadence, preventing the Operator from submitting claims either too quickly or too slowly.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="352-the-trunk-transaction-graph-and-parallel-verification">3.5.2. The Trunk Transaction Graph and Parallel Verification<a href="#352-the-trunk-transaction-graph-and-parallel-verification" class="hash-link" aria-label="Direct link to 3.5.2. The Trunk Transaction Graph and Parallel Verification" title="Direct link to 3.5.2. The Trunk Transaction Graph and Parallel Verification">​</a></h4>
<p>This recursive structure results in a transaction graph with a primary <strong>trunk</strong> that links the sequence of claims. At each claim on the trunk, a complete sub-graph for single-claim verification (as described in Section 3.4) branches off.</p>
<p>A critical feature of this design is that the submission of the next claim does not need to wait for the final resolution of the previous claim&#x27;s verification sub-protocol. The Operator can submit Claim <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> while the challenge window for Claim <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span> is still open. This parallelism is efficient but requires a mechanism to handle cascading failures. If Claim <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span> is successfully challenged, the protocol ensures that its state is invalid, which automatically invalidates the premise of all subsequent claims (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>N</mi><mo>+</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">N+1, N+2, \ldots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="minner">…</span></span></span></span>). A rational Operator, upon having a claim successfully challenged, is economically incentivized to cease submitting further claims, as each would require posting collateral that is doomed to be forfeited. The trunk would then terminate via a <code>ClaimTimeout</code> transaction.</p>
<p><img decoding="async" loading="lazy" alt="image" src="/assets/images/003-c5c090cdde4b9e5778bd36049f00822f.png" width="813" height="477" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="353-transaction-graph-reconfiguration-and-epochs">3.5.3. Transaction Graph Reconfiguration and Epochs<a href="#353-transaction-graph-reconfiguration-and-epochs" class="hash-link" aria-label="Direct link to 3.5.3. Transaction Graph Reconfiguration and Epochs" title="Direct link to 3.5.3. Transaction Graph Reconfiguration and Epochs">​</a></h4>
<p>Constructing, pre-signing, and storing a transaction graph intended to last for the entire lifecycle of the rollup (e.g., 100 years) is computationally and logistically infeasible for validators. It would also require an impossibly large amount of BTC to be locked as collateral upfront and would preclude any future protocol upgrades.</p>
<p>To solve these problems, we introduce <strong>Reconfiguration</strong>. The protocol&#x27;s timeline is divided into discrete <strong>epochs</strong>, with each epoch consisting of a fixed number of claims (e.g., lasting for two weeks). At the transition between epochs, a reconfiguration event occurs. For each attesting ceremony, the validator set only needs to pre-sign the trunk transaction graph for the upcoming epoch. This makes the burden on validators manageable.</p>
<p><strong>The Exit Window:</strong> Reconfiguration is also the point at which protocol upgrades or changes to the validator set can occur. These changes may alter the security assumptions or trust parameters of the system. To protect user sovereignty, Bitlayer provides a mandatory <strong>Exit Window</strong>. The configuration for Epoch <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">N+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">2</span></span></span></span> is proposed and finalized during Epoch <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span>. This gives users the entirety of Epoch <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> to review the new validator set and transaction graph for Epoch <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">N+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">2</span></span></span></span>. If a user does not approve of the upcoming changes, they have a full epoch to exit the system by withdrawing their assets (e.g., pegging-out BTC via the BitVM Bridge) before the new configuration takes effect.</p>
<p><strong>Validator Incentives:</strong> All validators are required to stake BTR tokens to participate. The pre-signing ceremony for each epoch&#x27;s transaction graph is coordinated through a system contract on the L2. Failure to participate in the ceremony in a timely manner results in the forfeiture of a portion of the validator&#x27;s staked BTR, strongly disincentivizing attacks designed to stall the protocol.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="354-the-reconfiguration-process">3.5.4. The Reconfiguration Process<a href="#354-the-reconfiguration-process" class="hash-link" aria-label="Direct link to 3.5.4. The Reconfiguration Process" title="Direct link to 3.5.4. The Reconfiguration Process">​</a></h4>
<p>The reconfiguration process is orchestrated by the L2 system contract. The designated operator prepares all necessary information for the next epoch&#x27;s transaction graph, and each validator independently generates it, signs it, and submits their signature to the L2 contract. Once a supermajority (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>−</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">N-f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span></span></span></span>) of valid signatures are collected, they are aggregated, and the attestation is complete.</p>
<p>This process culminates in a <strong>Reconfiguration transaction</strong> on Bitcoin. This transaction locks the aggregate collateral required for all claims in the new epoch and records the updated configuration parameters, such as the verifier program commitment <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span></span></span></span>, the operator&#x27;s identity, and time lock values. <strong>Reconfiguration transactions</strong> must be issued immediately after pre-signing is completed to promptly announce configurations. The very first such transaction, the <strong>Epoch 0 Reconfiguration transaction</strong>, bootstraps the entire rollup protocol and records the genesis state <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> of the Bitlayer network.</p>
<p><img decoding="async" loading="lazy" alt="image" src="/assets/images/004-055f72c5a808a0a251c15d4c5c03c067.png" width="1023" height="510" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="36-summary">3.6. Summary<a href="#36-summary" class="hash-link" aria-label="Direct link to 3.6. Summary" title="Direct link to 3.6. Summary">​</a></h3>
<p>In summary, the Bitlayer settlement protocol materializes as a perpetual, yet manageable, BitVM-style transaction graph on Bitcoin. This graph is cyclic, composed of per-epoch sub-graphs that are linked together through reconfiguration transactions. Each epoch&#x27;s sub-graph contains a trunk of chronologically linked state claims, and each claim is accompanied by its own verification sub-graph—a sophisticated challenge-response game that allows any single honest participant to enforce the correctness of the L2 state. This architecture enables Bitlayer to achieve a high degree of scalability and programmability while being securely anchored to Bitcoin&#x27;s unparalleled proof-of-work consensus.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="4-state-transition-function-and-batch-proof">4. State Transition Function and Batch Proof<a href="#4-state-transition-function-and-batch-proof" class="hash-link" aria-label="Direct link to 4. State Transition Function and Batch Proof" title="Direct link to 4. State Transition Function and Batch Proof">​</a></h2>
<p>Chapter 3 established how a state claim is settled on Bitcoin. This chapter details what is being settled: the execution of the Bitlayer Network STF over a batch of L2 blocks. We first define the components of our STF, including its unique system contracts. We then present the core technical contribution of this section: a multi-stage, recursive proving pipeline that uses a zero-knowledge virtual machine (zkVM) to generate a single, succinct proof for an entire batch of L2 activity, making verification on Bitcoin feasible.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="41-the-bitlayer-network-stf">4.1 The Bitlayer Network STF<a href="#41-the-bitlayer-network-stf" class="hash-link" aria-label="Direct link to 4.1 The Bitlayer Network STF" title="Direct link to 4.1 The Bitlayer Network STF">​</a></h3>
<p>Bitlayer Network’s STF aligns with the fundamental principles of Ethereum <a href="#ref9">[9]</a>. At the same time, as a Bitcoin rollup, it extends EVM with additional features and processes to address its unique requirements.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="411-gas-and-fee">4.1.1 Gas and Fee<a href="#411-gas-and-fee" class="hash-link" aria-label="Direct link to 4.1.1 Gas and Fee" title="Direct link to 4.1.1 Gas and Fee">​</a></h4>
<p>Transaction fees on Bitlayer Network are paid in BTC. Unlike native tokens that can be minted arbitrarily, BTC is safely injected into the Bitlayer network via the BitVM bridge
Bitlayer Network introduces a distinct gas model where transaction costs are separated into execution, storage, and Data Availability (DA) components. This allows for a dynamic fee mechanism that reflects both the transaction&#x27;s resource usage on L2 and the current data posting costs on the Bitcoin network.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="412-system-smart-contracts">4.1.2 System Smart Contracts<a href="#412-system-smart-contracts" class="hash-link" aria-label="Direct link to 4.1.2 System Smart Contracts" title="Direct link to 4.1.2 System Smart Contracts">​</a></h4>
<p>System Contracts in Bitlayer Network are a set of special-purpose contracts, deployed at genesis, that contain core protocol logic enforced during state transition verification. Changes to these contracts are managed by a governance mechanism, which oversees protocol evolution through a transparent voting process conducted by elected representatives.</p>
<p><strong>System Config</strong></p>
<p>The System Config contract defines core operational parameters for the STF, such as block gas limits and dynamic gas pricing. Its primary purpose is to allow for risk-managed adjustments, such as congestion control, in response to network conditions. Unlike the more rigid Reconfiguration process on L1, changes to the System Config are flexible, requiring agreement from the validators to take effect in the subsequent block.</p>
<p><strong>Validator Management</strong></p>
<p>The Validator Management contract is crucial for the network&#x27;s decentralized operation, overseeing the entire validator set on an epoch-by-epoch basis.</p>
<ul>
<li><strong>Participation and Selection</strong>: Participation is permissionless; anyone who meets a minimum staking threshold can stake BTR tokens to join the validator set. New stakers enter a pending queue, from which the protocol promotes new validators to the active set each epoch, up to a configured limit. Similarly, exiting validators enter an inactive queue for a defined period before their stake is released. The active validator set for each epoch is responsible for two primary functions: L2 block production and serving as the Attesting Committee for the Bitcoin Settlement Protocol and the BitVM Bridge.</li>
<li><strong>Incentives and Penalties</strong>: The contract enforces a clear economic model. Validators are rewarded in BTR for their work in securing the network, with rewards proportional to their stake and performance. This model includes role-specific incentives: the Rollup Operator receives additional BTR rewards to offset the costs and collateral risks of L1 settlement, while Attesters are rewarded for their participation in the pre-signing process. Conversely, any validator failing to adhere to the protocol faces penalties, including the slashing of their staked BTR.</li>
</ul>
<p><strong>Bitcoin Light Client Contract</strong></p>
<p>The Bitcoin Light Client ensures that significant Bitcoin L1 events are accurately reflected within the Bitlayer ecosystem.</p>
<ul>
<li><strong>Permissionless Monitoring</strong>: The off-chain &quot;Listeners&quot; monitors Bitcoin for relevant activities (e.g., pegin requests) and submits corresponding block data to the L2 light client contract. The listener is intentionally designed to be permissionless, Anyone can act as a Listener by submitting Bitcoin block headers to the contract. To process these potentially conflicting submissions, the contract enforces Bitcoin&#x27;s heaviest-chain fork choice rule to maintain the canonical chain. A submitted block is then considered finalized after accruing six or more subsequent confirmations.</li>
<li><strong>Liveness Guarantee</strong>: To ensure the L2 state remains synchronized with L1, the Rollup Operator is obligated to submit Bitcoin block updates if no one else does. This is enforced within the rollup&#x27;s proof system, which verifies that each new state claim corresponds to a minimum number of new Bitcoin blocks having been processed.</li>
<li><strong>Censorship Resistance</strong>: To guarantee a level of censorship resistance equivalent to Bitcoin, this contract enables a <strong>Force-Inclusion Transaction</strong> mechanism. A user can broadcast a transaction directly to Bitcoin using a specific format. The Bitlayer protocol obligates the Rollup Operator to process all such transactions &quot;seen&quot; by the light client on L1 within a defined time limit. This is enforced by the proving system: if a proposed batch fails to include a pending forced transaction, the proof generation will fail, leading to the Operator&#x27;s bond being slashed.</li>
</ul>
<p><strong>Bridge</strong></p>
<p>This contract manages the bidirectional flow of assets between Bitcoin and Bitlayer Network. When the Bitcoin Listener reports a pegin transaction, the Bridge contract is invoked to mint an equivalent amount of the asset on L2. It also handles the initiation of withdrawals (peg-out) from Bitlayer Network back to Bitcoin. The detailed logic of the bridge mechanism is discussed further in Chapter 5.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="42-transaction-lifecycle">4.2 Transaction lifecycle<a href="#42-transaction-lifecycle" class="hash-link" aria-label="Direct link to 4.2 Transaction lifecycle" title="Direct link to 4.2 Transaction lifecycle">​</a></h3>
<p><img decoding="async" loading="lazy" alt="image" src="/assets/images/005-eaef1e0f967973752d93fe4b381bf7ed.png" width="7924" height="4520" class="img_ev3q"></p>
<ul>
<li><strong>Sequencing:</strong> Users initiate transactions on the L2 network (Step 1a). These transactions are collected by the Sequencer component within the validator, while on-chain interactions (Step 1b), such as deposits and force inclusion transactions, are submitted to Bitcoin. The Bitcoin Listener component continuously monitors the Bitcoin and synchronizes L1 transactions to the Sequencer (Steps 2–3).</li>
<li><strong>Block Consensus:</strong> After collecting the transactions, one of the Sequencers is selected to propose a set of transactions. All the validators could reach an agreement on the ordering and content of the proposal through the consensus (Step 4). Once consensus is achieved, a sequenced L2 block is produced (Step 5).</li>
<li><strong>Execution:</strong> Once a block is produced, it is immediately executed by the validator (Step 6). This includes applying all transactions in the block to update the L2 state and storing the resulting state in the database. This ensures that every validator maintains a consistent and up-to-date view of the state.</li>
<li><strong>State Claim:</strong> After executing blocks, the Operator component fetches block data from the database (Step 7), assembles rollup batch information, and starts the Bitcoin settlement process as described in Chapter 3.</li>
<li><strong>Proof Generation:</strong> When a Watcher challenges the state claim posted by the Operator on Bitcoin, the Operator responds by generating a zero-knowledge proof (ZKP) to defend the correctness of the claimed state. To this end, the Operator submits proving tasks to the ZK Prover (Step 9). The Prover generates ZKPs based on the execution trace and state transition. These proofs are then returned to the Operator (Step 10) and submitted to Bitcoin (Step 11) as evidence supporting the validity of the rollup state.</li>
</ul>
<p>In the following section, we provide a detailed explanation of the Prover’s architecture and the internal structure of the generated proof.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="43-verifying-batch-proof">4.3 Verifying Batch Proof<a href="#43-verifying-batch-proof" class="hash-link" aria-label="Direct link to 4.3 Verifying Batch Proof" title="Direct link to 4.3 Verifying Batch Proof">​</a></h3>
<p>To verify the state transition function of our rollup protocol, we use a zkVM as the foundation of our constraint system and proof generation protocol. This section describes the architecture and operational flow of the zkVM-based proving system. The design leverages the flexibility of zkVMs to generate proofs directly from the existing execution codebase, utilizing a multi-stage, recursive workflow to ensure both the integrity and validity of computations. Ultimately, this process produces a final proof that can be efficiently verified on-chain.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="431-recursive-proving-pipeline">4.3.1 Recursive Proving Pipeline<a href="#431-recursive-proving-pipeline" class="hash-link" aria-label="Direct link to 4.3.1 Recursive Proving Pipeline" title="Direct link to 4.3.1 Recursive Proving Pipeline">​</a></h4>
<p>The core of the zkVM proving workflow is a sequential pipeline consisting of four distinct stages: STF Execution, Batch Aggregation, Batch Recursion, and Finalization. Each stage receives specific inputs, performs computations within the zkVM, and generates outputs that either feed into the next stage or contribute to the final verifiable proof. This recursive architecture enables efficient aggregation and compression of proofs, enhancing the scalability and efficiency of the system. The proving pipeline is illustrated in the following figure, and each stage will be described in detail.</p>
<p>The integrity of the STF is fundamentally secured by the <code>CodeCommitment</code>, the hash of the STF program binary. To ensure the integrity of the entire process, the <code>CodeControlGroup</code> is employed. This structure is an append-only Merkle Patricia Trie (MPT) that represents the outcome of social consensus: each leaf node of the MPT corresponds to a valid <code>CodeCommitment</code>. Operators usually publish the <code>CodeControlGroup</code> prior to a system upgrade, and it is accepted by all participants. This approach enables index-based lookup of valid code commitments, ensuring that all proofs are generated only from authorized and correctly specified program versions relevant to their operational context.</p>
<p><img decoding="async" loading="lazy" alt="image" src="/assets/images/006-02349809e60ad32921f0bb40f8428317.png" width="941" height="463" class="img_ev3q"></p>
<p><strong>Stage 1: State Transition Function Execution</strong></p>
<p>After the state transition of a single block is completed, the proof of correct execution is initiated within the zkVM for that block. The elements <code>Index</code>, <code>FromState</code>, <code>ToState</code>, and <code>Data</code> collectively serve as a claim of the correct outcome for the block’s execution. Here, <code>FromState</code> and <code>ToState</code> are cryptographic commitments (e.g., state roots) representing the state before and after the block’s execution, while <code>Index</code> provides a unique identifier for the processed block—typically the block number. <code>Data</code> represents the commitment to the operations processed within that block. In the current design, this is either the Merkle root of the transactions within the block or another representation of the state changes applied.</p>
<p><strong>Stage 2: Batch Aggregation</strong></p>
<p>Batch aggregation is used to combine multiple STF proofs from consecutive blocks and to record their associated STF program commitments. This stage takes several STF proofs as input and produces a batch proof as output. Batch aggregation not only demonstrates the correctness of multiple STF proofs, but also verifies the consistency between adjacent blocks. Specifically, it ensures that the <code>ToState</code> of the STF with <code>Index</code> is consistent with the <code>FromState</code> of the STF with <code>Index + 1</code>. Additionally, the <code>Data</code> from all blocks in the batch are combined into a single commitment, <code>DataIndexer</code>, indicating that the batch’s data has been successfully validated against the data availability layer.</p>
<p>Furthermore, the code commitments of the STF programs used to generate each input STF proof are extracted and recorded as <code>CodeCommitment</code>. This stage does not verify these STF code commitments against the <code>CodeControlGroup</code>; that verification is deferred to the Batch Recursion stage. The set of all valid STFs from previous stages is denoted as <code>ChainedSTFs</code>.</p>
<p><strong>Stage 3: Batch Recursion</strong></p>
<p>The primary purpose of the batch recursion stage is to recursively combine batch proofs, enabling the aggregation of proofs over progressively larger sequences of blocks while maintaining a constant-size proof.</p>
<p>In this stage, two zkVM proofs, including the new batch proof and the ongoing recursive proof, are combined into a new, single recursive proof. For the previous batch proof, each claimed STF program commitment (<code>CodeCommitment</code>) is validated against the <code>CodeControlGroup</code>, and the Batch Aggregation program is also validated against the <code>CodeControlGroup</code> based on the relevant execution index.</p>
<p>Likewise, both the previous recursive proof and the current Batch Recursion program must comply with the <code>CodeControlGroup</code> constraints for their respective historical index values. This comprehensive validation guarantees that the newly generated recursive proof correctly extends the chain of trust from the genesis block.</p>
<p>Batch Recursive will incrementally scan all claim transactions from the blocks in Bitcoin longest chain, making sure <code>ChainedSTFs</code> is consistent with the stated posted by claim transactions. At this stage, <code>CodeControlGroup</code>, <code>GenesisState</code>, <code>DataIndexer</code>, and <code>ChainedSTFs</code> collectively serve as the claims for the proof, with <code>ChainedSTFs</code> encapsulating the cumulative chained output, including the latest state.</p>
<p><strong>Stage 4: Settlement</strong></p>
<p>For settling the proof on the Bitcoin network, we utilize a final SNARG proof, which features polynomial size and polynomial verification time relative to the security parameter <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">λ</span></span></span></span>. This compaction circuit significantly reduces the computational load required for on-chain validation and remains fully compatible with the Bitcoin settlement protocol.</p>
<p>During this stage, a final check is performed to ensure that the recursive proving program version used to generate the input Recursive Proof adheres to the constraints of the <code>CodeControlGroup</code>. The <code>CodeControlRoot</code>, derived as the state root of the <code>CodeControlGroup</code> MPT, serves as a commitment to the entire authorized code history and all current valid code versions.</p>
<p>The claim produced at this stage contains all information necessary for the on-chain verifier, including <code>CodeControlRoot</code>, <code>GenesisState</code>, <code>FromState</code>, <code>ToState</code>, and <code>DataIndexer</code>. Watchers first observe this claim and may decide to challenge it by submitting a Challenge transaction to the Bitcoin network. If a watcher initiates a challenge, the proof is generated using the protocol described in this section. Otherwise, the proof is produced in the background for use in future claims.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="432-on-chain-verification-via-bitcoin-script">4.3.2 On-Chain Verification via Bitcoin Script<a href="#432-on-chain-verification-via-bitcoin-script" class="hash-link" aria-label="Direct link to 4.3.2 On-Chain Verification via Bitcoin Script" title="Direct link to 4.3.2 On-Chain Verification via Bitcoin Script">​</a></h4>
<p>The SNARG claim, generated by the zkVM proving pipeline, is specifically designed for efficient and secure verification on the Bitcoin blockchain using its native scripting capabilities. This verification process relies on a combination of static commitments embedded within the script template (established during pre-signing transactions) and dynamic inputs provided at runtime with the transaction containing the proof.</p>
<p><code>CodeControlRoot</code> and <code>GenesisState</code> are hard-coded in the script template. These two values are established prior to individual proof verification and serve as trust anchors for the system. The settlement proof (i.e., the SNARG proof), along with <code>FromState</code>, <code>ToState</code>, and <code>DataIndexer</code>, are specific to the particular state transition being verified.</p>
<p>The script combines the dynamic fields with the static <code>GenesisState</code> and <code>CodeControlRoot</code> (which also serve as public inputs to the ZK proof itself). These elements are hashed together on-chain to form a single, comprehensive <code>ClaimHash</code>. This <code>ClaimHash</code> represents the public statement that the ZK proof attests to, with its integrity ensured by on-chain computation.</p>
<p>Following the BitVM2 approach (see Chapter 3), the ZK proof verification logic is invoked optimistically. If the BitVM transaction graph accepts the proof, it confirms that:</p>
<ol>
<li>The claimed state transition from <code>FromState</code> to <code>ToState</code> is computationally valid according to the rules enforced by the zkVM programs;</li>
<li>The programs used were authorized as defined by the <code>CodeControlRoot</code>;</li>
<li>All relevant data was made available as defined by the <code>DataIndexer</code>;</li>
<li>The entire history traces back to the <code>GenesisState</code>.</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="5-bridging-bitcoin-and-bitlayer-network">5. Bridging Bitcoin and Bitlayer Network<a href="#5-bridging-bitcoin-and-bitlayer-network" class="hash-link" aria-label="Direct link to 5. Bridging Bitcoin and Bitlayer Network" title="Direct link to 5. Bridging Bitcoin and Bitlayer Network">​</a></h2>
<p>A secure rollup requires a correspondingly secure mechanism for asset transfers between the L1 and L2. This chapter details the Bitlayer Asset Bridge, the mechanism for transferring assets between Bitcoin and the Bitlayer Network. The bridge is built upon the same BitVM paradigm as our settlement protocol, ensuring a unified security model for both state validity and asset custody.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="51-roles">5.1 Roles<a href="#51-roles" class="hash-link" aria-label="Direct link to 5.1 Roles" title="Direct link to 5.1 Roles">​</a></h3>
<p>The bridge protocol involves several key roles:</p>
<ol>
<li><strong>Users:</strong> Asset holders who initiate transfers between Bitcoin and Bitlayer Network.</li>
<li><strong>Broker:</strong> Assists users in preparing deposits and withdrawals, including constructing initial transaction graphs and obtaining signatures from Attesters. Brokers directly interface with users, abstracting the complexity of the BitVM protocol and enabling seamless interaction</li>
<li><strong>Attesting Committee:</strong> This is the same validator set from the rollup protocol. The committee elected for a specific Epoch N is responsible for pre-signing the transaction graphs for all bridge requests initiated within that epoch.</li>
<li><strong>Watcher:</strong> Permissionless observers who monitor the protocol and challenge malicious behavior.</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="52-asset-cross-chain-flow">5.2 Asset Cross-Chain Flow<a href="#52-asset-cross-chain-flow" class="hash-link" aria-label="Direct link to 5.2 Asset Cross-Chain Flow" title="Direct link to 5.2 Asset Cross-Chain Flow">​</a></h3>
<p>Below we use BTC as an example to introduce the complete process of asset deposit and withdrawal.</p>
<p><img decoding="async" loading="lazy" alt="image" src="/assets/images/007-a4633e84bd3faf46547e5d67a547a025.png" width="1377" height="299" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="521-asset-deposit-peg-in">5.2.1 Asset Deposit (Peg-in)<a href="#521-asset-deposit-peg-in" class="hash-link" aria-label="Direct link to 5.2.1 Asset Deposit (Peg-in)" title="Direct link to 5.2.1 Asset Deposit (Peg-in)">​</a></h4>
<p>The peg-in process moves assets from Bitcoin to Bitlayer and is initiated by the user in several steps:</p>
<ol>
<li><strong>Initiate Request:</strong> The user submits a <code>PeginRequest</code> to all brokers, specifying the UTXOs for deposit, the target Bitlayer Network address, and a Bitcoin address for transaction change.</li>
<li><strong>Preparation:</strong> A broker responds with a complete <code>Pegin</code> transaction and the associated transaction graph. The user must carefully verify its correctness, ensuring all parameters meet their expectations.</li>
<li><strong>Broadcast &amp; Mint:</strong> After verification, the user broadcasts the <code>Pegin</code> transaction on the Bitcoin network. Once the Pegin transaction is confirmed on L1, the Bitcoin Light Client on L2 (as described in Chapter 4) recognizes it. Anyone can then submit a proof of this transaction to the Bridge contract on L2, which triggers the minting of an equivalent amount of BTC to the user&#x27;s specified address.</li>
</ol>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="522-asset-withdrawal-peg-out">5.2.2 Asset Withdrawal (Peg-out)<a href="#522-asset-withdrawal-peg-out" class="hash-link" aria-label="Direct link to 5.2.2 Asset Withdrawal (Peg-out)" title="Direct link to 5.2.2 Asset Withdrawal (Peg-out)">​</a></h4>
<p>The standard peg-out process is designed for efficiency, relying on Brokers to provide upfront liquidity for a fast user experience::</p>
<ol>
<li><strong>Initiate Burn:</strong> The user initiates a <strong>Burn transaction</strong> on the Bitlayer Network. This transaction burns a specific amount of BTC on the L2 and specifies two key parameters: the amount of BTC the user wishes to receive on the Bitcoin mainnet and the recipient&#x27;s address. The difference between the amount burned on Bitlayer Network and the amount to be received on Bitcoin constitutes the fee for the Broker.</li>
<li><strong>Broker Fronts Funds:</strong> The Broker monitors for these  <strong>Burn transaction</strong>. If a Broker finds the fee acceptable, they will immediately front the requested funds to the user&#x27;s specified address on the Bitcoin mainnet, efficiently completing the withdrawal.</li>
</ol>
<p>After fronting the funds, the Broker needs to reclaim their capital from the protocol through the security mechanism detailed below.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="53-broker-funds-reclamation">5.3 Broker Funds Reclamation<a href="#53-broker-funds-reclamation" class="hash-link" aria-label="Direct link to 5.3 Broker Funds Reclamation" title="Direct link to 5.3 Broker Funds Reclamation">​</a></h3>
<p>To recover their fronted funds, the Broker initiates a verification process by submitting a <strong>KickOff transaction</strong> to the protocol. This submission serves as an assertion that the Broker has legitimately fulfilled a valid <strong>Burn transaction</strong>. The verification follows the same optimistic, challenge-response game used for state settlement in Chapter 3, where the Broker&#x27;s assertion is assumed correct unless challenged.</p>
<ul>
<li><strong>Challenge Process:</strong> Watchers verify the legitimacy of this Reclaim Claim. If any invalidity is found (e.g., the corresponding <code>Burn</code> transaction does not exist or is invalid), a Watcher will publish a <code>Challenge</code> transaction.</li>
<li><strong>Assertion and Penalty:</strong> Upon being challenged, the Broker must respond within a specified time with an <strong>Assert transaction</strong>, which must contain a <strong>Groth16 ZKP</strong>. If a Watcher can verify that this proof is invalid, they can publish a <strong>Disprove transaction</strong> to penalize the Broker and receive a portion of their bonded collateral as a reward. This game-theoretic process is mechanically identical to the Single Claim Verification Protocol described in Chapter 3.</li>
</ul>
<p>This reclaim verification mechanism relies on the <strong>Bitlayer Light Client</strong> and depends on the Bitcoin mainnet for the finality of Bitlayer Network transactions. Therefore, a <strong>Burn transaction</strong> is considered valid only after it has been included in a Batch and achieved Hard Finality on Bitcoin. If challenged, the Groth16 proof provided by the Broker must contain a complete verification chain from the Bitlayer Network&#x27;s Genesis State to the current state to prove the validity and authenticity of the <strong>Burn transaction</strong>.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="54-escape-hatch">5.4 Escape Hatch<a href="#54-escape-hatch" class="hash-link" aria-label="Direct link to 5.4 Escape Hatch" title="Direct link to 5.4 Escape Hatch">​</a></h3>
<p>The bridge includes an escape hatch to guarantee user sovereignty over their assets, even if the L2 protocol halts. A halt can occur if the Operator repeatedly fails to submit new claims or if a submitted claim is successfully challenged. In this scenario, while the Operator&#x27;s collateral is slashed and the L2 state is protected from further invalid updates, user funds could become locked. The escape hatch provides a new path for withdrawal, which also relies on Brokers for liquidity.</p>
<p>The process unfolds as follows:</p>
<ol>
<li><strong>User-Initiated Forced Withdrawal</strong>: A user initiates an emergency withdrawal by broadcasting a force-inclusion withdrawal transaction directly to the Bitcoin L1. This transaction contains a signature proving ownership of the L2 account and specifies the L1 address for receiving the funds. While this L1 transaction cannot be fully processed by the stalled rollup, it serves as an immutable, on-chain withdrawal request.</li>
<li><strong>Broker Fronts Funds</strong>: Brokers monitor the Bitcoin L1 for these forced withdrawal requests. After aggregating a sufficient number of requests to meet a predefined threshold, a Broker can choose to front the liquidity, sending the funds directly to the users&#x27; specified L1 addresses.</li>
<li><strong>Broker Funds Reclamation</strong>: To reclaim their fronted capital, the Broker submits a reclaim claim to the bridge protocol, accompanied by a single Groth16 proof. This proof must validate three distinct conditions:<!-- -->
<ol>
<li><strong>Proof of L2 Halt</strong>: Evidence that the rollup protocol is stalled. This is confirmed either by showing a CommitBatchTimeout transaction (indicating the Operator&#x27;s failure to submit a new batch) or a successful slash transaction (indicating the last submitted batch was fraudulent).</li>
<li><strong>Proof of Valid User Request</strong>: Evidence that the user&#x27;s withdrawal request is legitimate. This requires proving the existence of the force-inclusion transaction on L1 (via the Bitcoin Light Client) and confirming the user had a sufficient balance in the last correctly finalized L2 state.</li>
<li><strong>Proof of Fulfillment</strong>: Evidence that the Broker has already sent the corresponding funds to the user on L1, also confirmed via the Bitcoin Light Client.</li>
</ol>
</li>
</ol>
<p>This escape hatch mechanism ensures that users always retain control of their assets, relying only on the security of the Bitcoin L1 and the economic incentives of the Broker network. We will explore using account abstraction to define more intelligent withdrawal logic and extending this mechanism to support the emergency withdrawal of assets held within smart contracts.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="6-security-analysis">6. Security Analysis<a href="#6-security-analysis" class="hash-link" aria-label="Direct link to 6. Security Analysis" title="Direct link to 6. Security Analysis">​</a></h2>
<p>This chapter presents a comprehensive analysis of the security that underpins the Bitlayer Rollup. We begin by introducing a general security model for BitVM-style smart contracts, followed by definitions and proofs of their safety and liveness properties. We then conduct a detailed analysis of the Bitcoin settlement security properties discussed in Chapter 3. Finally, we briefly described the inherent censorship resistance provided by decentralized networks.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="61-bitvm-style-smart-contract-security">6.1 BitVM-Style Smart Contract Security<a href="#61-bitvm-style-smart-contract-security" class="hash-link" aria-label="Direct link to 6.1 BitVM-Style Smart Contract Security" title="Direct link to 6.1 BitVM-Style Smart Contract Security">​</a></h3>
<p>BitVM-style smart contracts follow a universal transaction graph structure. In this section, we provide a general security analysis applicable to all BitVM-style contracts, including the Bitlayer Rollup contract.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="611-system-model--assumptions">6.1.1 System Model &amp; Assumptions<a href="#611-system-model--assumptions" class="hash-link" aria-label="Direct link to 6.1.1 System Model &amp; Assumptions" title="Direct link to 6.1.1 System Model &amp; Assumptions">​</a></h4>
<p>In a BitVM-style smart contract, at least three roles are required to collaborate:</p>
<ul>
<li><strong>Transaction Graph Proposer:</strong> The Proposer is responsible for initiating a contract instance, the Proposer must stake a predefined amount of BTC, serving as both a commitment and a deterrent against misbehavior.</li>
<li><strong>Attesters:</strong> We assume there are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> Attesters, among whom <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span> are honest. The remaining <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n-m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span> are semi-honest, meaning they follow the protocol and collaborate to construct the presigned signature but may behave unpredictably off-protocol, such as retaining keys after presigning. Each presigning requires the participation of at least <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> Attesters.</li>
<li><strong>Watchers:</strong> Watchers monitor the on-chain state submitted by the Proposer to ensure correctness. If misbehavior is detected, they can hold the Proposer accountable by invoking penalties on the staked BTC. The model assumes the existence of at least one rational, honest, and active Watcher.</li>
</ul>
<p>Additionally, we assume a <strong>synchronized network</strong>, where all communications between participants and the Bitcoin network occur within a known bounded time <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Δ</span></span></span></span>. All participants are assumed to be rational and polynomial-time bounded, meaning all cryptographic tools used in the BitVM-style smart contract are secure.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="612-transaction-graph-model">6.1.2 Transaction Graph Model<a href="#612-transaction-graph-model" class="hash-link" aria-label="Direct link to 6.1.2 Transaction Graph Model" title="Direct link to 6.1.2 Transaction Graph Model">​</a></h4>
<p>The Transaction Graph serves as the backbone of the BitVM-style smart contract, structured as a directed acyclic graph (DAG). This model provides clarity and enforceability to the contract’s execution.</p>
<p><img decoding="async" loading="lazy" alt="Transaction Graph DAG" src="/assets/images/008-8c440317f059551fc7db2931306bd05e.png" width="5204" height="4524" class="img_ev3q"></p>
<ul>
<li><strong>Preceding Txs:</strong> The transactions provide the initial outputs necessary for the contract’s execution, which include the Proposer’s stake reserve and the Watcher’s reserve. The Attesters must validate the existence and correctness of these transactions before presigning.</li>
<li><strong>Presigned Txs:</strong> The transactions that Attesters need to presign, which determines the logic of the BitVM-style contract.</li>
<li><strong>Sink Txs:</strong> The transactions, lacking outgoing edges in the DAG, signify the release of funds.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="613-design-principles">6.1.3 Design Principles<a href="#613-design-principles" class="hash-link" aria-label="Direct link to 6.1.3 Design Principles" title="Direct link to 6.1.3 Design Principles">​</a></h4>
<ul>
<li><strong>Stake:</strong> The Proposer must stake a specified amount of BTC to initiate the contract. (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">d</span></span></span></span> BTC in the graph).</li>
<li><strong>Slashable:</strong> Incorrect STF submitted by the Proposer can result in the slashing of their staked BTC.</li>
<li><strong>Termination:</strong> All outputs containing amounts in the presigned transactions must have a timelock path (which may involve multiple transactions) leading to Sink Txs, ensuring the contract eventually terminates.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="614-safety">6.1.4 Safety<a href="#614-safety" class="hash-link" aria-label="Direct link to 6.1.4 Safety" title="Direct link to 6.1.4 Safety">​</a></h4>
<p><strong>Safety Goals</strong></p>
<ul>
<li><strong>Validity:</strong> Every transaction in the Transaction Graph must be valid post-presigning.</li>
<li><strong>Integrity:</strong> No new transactions can be added to the Transaction Graph after presigning.</li>
<li><strong>Flexibility:</strong> The BitVM-style smart contract can accommodate different security assumptions, depending on the application scenario.</li>
</ul>
<p><strong>Lemma 1:</strong> Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>t</mi><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>t</mi><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{tx_1, ..., tx_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> be the presigned transactions spending <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>t</mi><mi>x</mi><msub><mi>o</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">utxo_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>. No transaction <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo mathvariant="normal">∉</mo><mo stretchy="false">{</mo><mi>t</mi><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>t</mi><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">tx&#x27;\notin\{tx_1, ..., tx_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> can spend <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>t</mi><mi>x</mi><msub><mi>o</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">utxo_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>.</p>
<p><strong>Proof:</strong> We prove this important lemma by contradiction. Assume a presign committee <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>a</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>e</mi><msub><mi>r</mi><mn>0</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>a</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>e</mi><msub><mi>r</mi><mrow><mi>n</mi><mo>−</mo><mi>m</mi></mrow></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{attester_0, ..., attester_{n-m}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> performed the setup presigning. If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">tx&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> exists, it indicates that the Attesters have performed additional signing outside of the setup phase, which implies that these <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> Attesters are semi-honest. This contradicts the assumption.</p>
<p><strong>Lemma 2:</strong> Each presign committee must include at least one honest Attester.</p>
<p><strong>Theorem 1 (Validity):</strong> If a valid presigned signature <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span></span></span></span> is produced for a transaction <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">tx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">x</span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">tx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">x</span></span></span></span> is valid.</p>
<p><strong>Proof:</strong> By Lemma 2, at least one honest Attester <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> participated in the presigning and contributed partial signature σi for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">tx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">x</span></span></span></span>. Hence, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">tx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">x</span></span></span></span> received by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> must be valid. Since the validity of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span></span></span></span> relies on all Attesters contributing partial signatures to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">tx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">x</span></span></span></span>, it must be valid.</p>
<p><strong>Theorem 2 (Integrity)</strong></p>
<p><strong>Proof:</strong> Except for Sink Transactions, all outputs must require a multi-signature from the presign committee. By Lemma 1, we can conclude that all participants can only spend the UTXOs in the Transaction Graph along the predefined path, ensuring the integrity of the BitVM-style smart contract.</p>
<p><strong>Theorem 3 (Flexibility)</strong></p>
<p><strong>Proof:</strong> We can dynamically adjust the security assumptions of the Attesters based on the requirements of the application scenario, as long as the presign committee ultimately includes at least one honest node. Based on Lemma 1 and Lemma 2, validity and integrity can then be deduced.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="615-liveness">6.1.5 Liveness<a href="#615-liveness" class="hash-link" aria-label="Direct link to 6.1.5 Liveness" title="Direct link to 6.1.5 Liveness">​</a></h4>
<p><strong>Liveness at the Setup Phase</strong>
The setup phase is inherently fragile in terms of liveness. If even a single Attester refuses to cooperate, the entire contract setup will fail. This underscores the importance of coordination and trust among participants during the initial setup phase.</p>
<p><strong>Attester Rotation</strong>
To address the liveness fragility problem without compromising security or fungibility, we propose maintaining a pool of Attesters on the Bitlayer Rollup. Instead of requiring all Attesters to be online, a fixed number of Attesters will be randomly selected from this pool to form the presign committee for each instance. If the presign process fails to complete within a specified time, a new committee will be selected. Additionally, Attesters who fail to respond will be penalized and temporarily excluded from participating in subsequent committee selections.</p>
<p><strong>Liveness at the Execution Phase</strong></p>
<p><strong>Liveness Goal</strong></p>
<ul>
<li><strong>Funds Liquidity:</strong> Funds involved in the contract’s Preceding Txs must not remain indefinitely locked.</li>
</ul>
<p><strong>Theorem 4 (Funds Liquidity)</strong></p>
<p><strong>Proof:</strong> Since the timelock duration is known and finite, the Termination principle of the Transaction Graph ensures that all funds will eventually be unlocked and flow to Sink Txs within a finite time.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="62-bitcoin-settlement-security">6.2 Bitcoin Settlement Security<a href="#62-bitcoin-settlement-security" class="hash-link" aria-label="Direct link to 6.2 Bitcoin Settlement Security" title="Direct link to 6.2 Bitcoin Settlement Security">​</a></h3>
<p>This section focuses on proving the Bitcoin settlement security properties introduced in Chapter 3.4.4.</p>
<p><strong>Lemma 3 (Completeness):</strong> An honest Operator who correctly follows the protocol and submits valid state claims will never be unjustly penalized.</p>
<p><strong>Proof:</strong> An honest operator publishes valid claims and sub-program results within the required time windows, ensuring no inconsistencies arise. As a result, no watcher can unlock a <em>Disprove Script</em>, and the operator is not penalized. To save space, the details are omitted here.</p>
<p><strong>Lemma 4 (Soundness):</strong> A dishonest Operator who submits a fraudulent claim cannot avoid being penalized, as an honest Watcher will always be able to construct a valid <em>Disprove</em> transaction.</p>
<p><strong>Proof:</strong></p>
<p>If the dishonest operator does not publish <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Φ</span></span></span></span> within <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mrow><mi>c</mi><mi>l</mi><mi>a</mi><mi>i</mi><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Delta_{claim}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span><span class="mord mathnormal mtight">aim</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>, the operator will be penalized. During the Claim Phase, the dishonest operator publishes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Φ</span></span></span></span>. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">SNARG.Vrfy</mtext></mrow><annotation encoding="application/x-tex">\texttt{SNARG.Vrfy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.2222em"></span><span class="mord text"><span class="mord texttt">SNARG.Vrfy</span></span></span></span></span> will fail locally for watchers, they raise a challenge within <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mtext>challenge</mtext></msub></mrow><annotation encoding="application/x-tex">\Delta_{\text{challenge}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">challenge</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span>, moving the protocol to the Challenge Phase. If the operator does not publish the result of all sub-programs within time <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mrow><mi>a</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Delta_{assert}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em">sser</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>, the operator will be penalized.</p>
<p>If there is a disproved algorithm allowing watchers to unlock a <em>Disprove Script</em> with inputs and outputs published by the operator that contradict the sub-program execution, then a dishonest operator cannot escape penalties.</p>
<p>We prove the existence of the disprove algorithm as follows. First, since the inputs and outputs published by the operator contradict the local sub-program execution, there must be at least one inconsistent output produced by the sub-program, saying <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>. Then, we check the consistency of the inputs of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>. If all inputs are consistent, we select <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> as the challenged sub-program, otherwise recursively run the first step for one of the inconsistent inputs. So, the disprove algorithm must successfully select a sub-program to challenge.</p>
<p><strong>Lemma 5 (Efficiency):</strong> The entire claim verification process, whether it results in acceptance or rejection, is guaranteed to terminate within a bounded timeframe defined by the protocol&#x27;s time locks.</p>
<p><strong>Proof:</strong> Each phase of the protocol has a bounded time. If both the Operator and Watcher are honest in following the protocol, the optimistic time bound is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mrow><mi>c</mi><mi>l</mi><mi>a</mi><mi>i</mi><mi>m</mi></mrow></msub><mo>+</mo><msub><mi mathvariant="normal">Δ</mi><mrow><mi>c</mi><mi>h</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Delta_{claim} + \Delta_{challenge}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span><span class="mord mathnormal mtight">aim</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">ha</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">ll</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">g</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span>. If either the Operator or any Watcher tries to destroy the protocol, the time-bound will become <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mrow><mi>c</mi><mi>l</mi><mi>a</mi><mi>i</mi><mi>m</mi></mrow></msub><mo>+</mo><msub><mi mathvariant="normal">Δ</mi><mrow><mi>a</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>t</mi></mrow></msub><mo>+</mo><msub><mi mathvariant="normal">Δ</mi><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>v</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Delta_{claim} + \Delta_{assert} +\Delta_{disprove}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span><span class="mord mathnormal mtight">aim</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em">sser</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">ro</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span>. Thus, the maximum time bound to confirm is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mrow><mi>c</mi><mi>l</mi><mi>a</mi><mi>i</mi><mi>m</mi></mrow></msub><mo>+</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">{</mo><msub><mi mathvariant="normal">Δ</mi><mrow><mi>c</mi><mi>h</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>e</mi></mrow></msub><mo separator="true">,</mo><msub><mi mathvariant="normal">Δ</mi><mrow><mi>a</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>t</mi></mrow></msub><mo>+</mo><msub><mi mathvariant="normal">Δ</mi><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>v</mi><mi>e</mi></mrow></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Delta_{claim} + \max\{\Delta_{challenge}, \Delta_{assert} + \Delta_{disprove}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span><span class="mord mathnormal mtight">aim</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em"></span><span class="mop">max</span><span class="mopen">{</span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">ha</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">ll</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">g</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em">sser</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">ro</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>, so that the protocol terminates regardless of whether the claim is accepted or rejected. Thus, the protocol guarantees efficiency by design.</p>
<p><img decoding="async" loading="lazy" alt="image" src="/assets/images/009-a01d921a5f7c10f97c78c52f206ce533.png" width="761" height="317" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="63-censorship-resistance">6.3 Censorship Resistance<a href="#63-censorship-resistance" class="hash-link" aria-label="Direct link to 6.3 Censorship Resistance" title="Direct link to 6.3 Censorship Resistance">​</a></h3>
<p>Unlike traditional L2 architectures that rely on a single sequencer, our design employs a rotating manner among validators to produce blocks. This decentralized sequencing mechanism ensures that no single party can unilaterally censor transactions. As block production rotates among validators in a permissionless and stake-weighted manner, any attempt to exclude valid transactions can be bypassed in subsequent blocks, providing strong built-in censorship resistance and enhancing the neutrality of the network.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="7-limitations-and-future-directions">7. Limitations and Future Directions<a href="#7-limitations-and-future-directions" class="hash-link" aria-label="Direct link to 7. Limitations and Future Directions" title="Direct link to 7. Limitations and Future Directions">​</a></h2>
<p>This chapter reflects on the current design of the Bitlayer Network, discussing its inherent trade-offs and the promising research avenues they inspire. We first outline the primary limitations of our current protocol and then detail future work aimed at addressing these challenges and further advancing the capabilities of Bitcoin L2s.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="71-limitations">7.1 Limitations<a href="#71-limitations" class="hash-link" aria-label="Direct link to 7.1 Limitations" title="Direct link to 7.1 Limitations">​</a></h3>
<p>While the Bitlayer Network provides a robust framework for a Bitcoin computational layer, its current design involves several trade-offs:</p>
<ol>
<li><strong>Trust Dependency on the Attester Committee:</strong> The security of the bridge and settlement protocol relies on a 1-of-N honest-minority assumption within the Attester Committee. While this provides strong security, eliminating this external committee through future Bitcoin protocol upgrades remains a key goal for achieving a more fully trustless system.</li>
<li><strong>Centralized Operator and Liveness:</strong> The current model uses a single, rotating Rollup Operator for sequencing and settlement. While this is efficient, it presents a potential single point of failure for liveness if the operator goes offline. This motivates the development of a multi-operator mechanism.</li>
<li><strong>Reliance on Broker Liquidity:</strong> The fast withdrawal and emergency escape hatch mechanisms depend on an active network of third-party Brokers to provide upfront liquidity. The system&#x27;s user experience and capital efficiency could be further improved by protocol-native solutions that reduce this reliance.</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="72-future-directions">7.2 Future Directions<a href="#72-future-directions" class="hash-link" aria-label="Direct link to 7.2 Future Directions" title="Direct link to 7.2 Future Directions">​</a></h3>
<p>We are actively researching several enhancements to address these limitations and expand the network&#x27;s capabilities::</p>
<ol>
<li>
<p><strong>Leveraging Future Bitcoin Upgrades (Covenants):</strong> Upcoming potential Bitcoin protocol upgrades, such as those introducing new covenant opcodes (e.g., <code>OP_CTV</code> <a href="#ref10">[10]</a>, <code>OP_CAT</code>, or similar proposals), could pave the way for more trustless smart contract functionalities directly on Bitcoin. We are closely monitoring these developments and plan to integrate such features, if and when they become available and stable. This could allow for:</p>
<ul>
<li><strong>Elimination of Attester Committees:</strong> Potentially removing the need for an attester committee for certain verification processes, moving towards a more fully trustless model.</li>
<li><strong>Enhanced Permissionlessness:</strong> Reducing reliance on pre-signed transactions or specific roles in the dispute resolution protocol, making the system even more open.</li>
<li><strong>On-Chain Operator Election:</strong> Managing Rollup Operator election and rotation more directly on-chain, further enhancing liveness and decentralization.</li>
<li><strong>Optimized Collateral Management:</strong> Enabling more sophisticated collateral reuse mechanisms within the same epoch without compromising security, thereby reducing the capital costs for operators.</li>
</ul>
</li>
<li>
<p><strong>Advanced Proving Systems:</strong> Continuously evaluating and integrating advancements in zero-knowledge proof systems and other cryptographic techniques to improve proof generation efficiency, reduce on-chain verification costs, and enhance overall system performance.</p>
</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusions">Conclusions<a href="#conclusions" class="hash-link" aria-label="Direct link to Conclusions" title="Direct link to Conclusions">​</a></h2>
<p>In this paper, we have introduced Bitlayer, a scalable and EVM-compatible computational layer for Bitcoin, whose security is based on an honest majority assumption. Bitlayer is built upon the BitVM paradigm to enable complex, general-purpose computation while anchoring its security directly to the Bitcoin network. Our core contribution is a novel recursive settlement protocol, the first of its kind to allow for the continuous, verifiable settlement of Layer 2 state transitions on Bitcoin. This protocol, combined with a synergistic asset bridge sharing the same security model and a fully EVM-compatible execution layer, creates a complete and practical platform for decentralized applications.</p>
<p>We view Bitlayer as a foundational step towards building the premier infrastructure for the BTCFi ecosystem. By demonstrating a clear architecture where Bitcoin acts as the ultimate settlement layer and Bitlayer as an efficient, verifiable computational layer, our work provides a practical blueprint for unlocking Bitcoin&#x27;s vast potential. We hope that our design, which prioritizes low transaction costs and strong censorship resistance, encourages further research into scalable and secure applications built upon Bitcoin.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="references">References<a href="#references" class="hash-link" aria-label="Direct link to References" title="Direct link to References">​</a></h2>
<p><span id="ref1">1</span>. S. Nakamoto. Bitcoin: A Peer-to-Peer Electronic Cash System, 2009. <a href="http://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener noreferrer">http://bitcoin.org/bitcoin.pdf</a>.</p>
<p><span id="ref2">2</span>. Linus, Robin, Lukas Aumayr, Alexei Zamyatin, Andrea Pelosi, Zeta Avarikioti, and Matteo Maffei. BitVM2: Bridging Bitcoin to Second Layers. <a href="https://bitvm.org/bitvm_bridge.pdf" target="_blank" rel="noopener noreferrer">https://bitvm.org/bitvm_bridge.pdf</a></p>
<p><span id="ref3">3</span>. Robin Linus. BitVM: Compute anything on bitcoin, December 2023. <a href="https://bitvm.org/bitvm.pdf" target="_blank" rel="noopener noreferrer">https://bitvm.org/bitvm.pdf</a></p>
<p><span id="ref4">4</span>. J. Groth. On the size of pairing-based non-interactive arguments, 2016. <a href="https://eprint.iacr.org/2016/260.pdf" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2016/260.pdf</a></p>
<p><span id="ref5">5</span>. Dan Boneh and Victor Shoup. A Graduate Course in Applied Cryptography
. <a href="https://toc.cryptobook.us/book.pdf" target="_blank" rel="noopener noreferrer">https://toc.cryptobook.us/book.pdf</a></p>
<p><span id="ref6">6</span>. Bitcoin Wiki. Script, 2025. <a href="https://en.bitcoin.it/wiki/Scrip" target="_blank" rel="noopener noreferrer">https://en.bitcoin.it/wiki/Scrip</a></p>
<p><span id="ref7">7</span>. Kalodner, H., Goldfeder, S., Chen, X., Weinberg, S. M., &amp; Felten, E. W. (2018). Arbitrum: Scalable, private smart contracts. In 27th USENIX Security Symposium (USENIX Security 18). <a href="https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-kalodner.pdf" target="_blank" rel="noopener noreferrer">https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-kalodner.pdf</a></p>
<p><span id="ref8">8</span>. J. Buchmann, E. Dahmen, S. Ereth, A. H¨ulsing, and M. R¨uckert. On the security of the winternitz one-time signature scheme, 2011. <a href="https://eprint.iacr.org/2011/191.pdf" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2011/191.pdf</a></p>
<p><span id="ref9">9</span>. Wood, G. (2014). &quot;Ethereum: A Secure Decentralised Generalised Transaction Ledger.&quot; Ethereum Project Yellow Paper. <a href="https://ethereum.github.io/yellowpaper/paper.pdf" target="_blank" rel="noopener noreferrer">https://ethereum.github.io/yellowpaper/paper.pdf</a></p>
<p><span id="ref10">10</span>. Rubin, J. (2020). &quot;BIP-0119: CHECKTEMPLATEVERIFY.&quot; Bitcoin Improvement Proposals. <a href="https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki" target="_blank" rel="noopener noreferrer">https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki</a></p></div></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/Learn/Bitlayer Rollup/bridge"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Trust-minimized BTC Bridge</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/Learn/Technologies/overview"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Overview</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#abstract" class="table-of-contents__link toc-highlight">Abstract</a></li><li><a href="#1-introduction" class="table-of-contents__link toc-highlight">1. Introduction</a></li><li><a href="#2-network-architecture" class="table-of-contents__link toc-highlight">2. Network Architecture</a><ul><li><a href="#21-network-participants-and-roles" class="table-of-contents__link toc-highlight">2.1. Network Participants and Roles</a></li><li><a href="#22-dual-level-transaction-finality" class="table-of-contents__link toc-highlight">2.2. Dual-Level Transaction Finality</a></li></ul></li><li><a href="#3-settling-l2-state-on-bitcoin" class="table-of-contents__link toc-highlight">3. Settling L2 State on Bitcoin</a><ul><li><a href="#31-defining-the-l2-state-claim" class="table-of-contents__link toc-highlight">3.1. Defining the L2 State Claim</a></li><li><a href="#32-cryptographic-primitives" class="table-of-contents__link toc-highlight">3.2. Cryptographic Primitives</a></li><li><a href="#33-protocol-overview" class="table-of-contents__link toc-highlight">3.3. Protocol Overview</a></li><li><a href="#34-settling-a-single-claim" class="table-of-contents__link toc-highlight">3.4. Settling a Single Claim</a></li><li><a href="#35-settling-a-chain-of-claims" class="table-of-contents__link toc-highlight">3.5. Settling a Chain of Claims</a></li><li><a href="#36-summary" class="table-of-contents__link toc-highlight">3.6. Summary</a></li></ul></li><li><a href="#4-state-transition-function-and-batch-proof" class="table-of-contents__link toc-highlight">4. State Transition Function and Batch Proof</a><ul><li><a href="#41-the-bitlayer-network-stf" class="table-of-contents__link toc-highlight">4.1 The Bitlayer Network STF</a></li><li><a href="#42-transaction-lifecycle" class="table-of-contents__link toc-highlight">4.2 Transaction lifecycle</a></li><li><a href="#43-verifying-batch-proof" class="table-of-contents__link toc-highlight">4.3 Verifying Batch Proof</a></li></ul></li><li><a href="#5-bridging-bitcoin-and-bitlayer-network" class="table-of-contents__link toc-highlight">5. Bridging Bitcoin and Bitlayer Network</a><ul><li><a href="#51-roles" class="table-of-contents__link toc-highlight">5.1 Roles</a></li><li><a href="#52-asset-cross-chain-flow" class="table-of-contents__link toc-highlight">5.2 Asset Cross-Chain Flow</a></li><li><a href="#53-broker-funds-reclamation" class="table-of-contents__link toc-highlight">5.3 Broker Funds Reclamation</a></li><li><a href="#54-escape-hatch" class="table-of-contents__link toc-highlight">5.4 Escape Hatch</a></li></ul></li><li><a href="#6-security-analysis" class="table-of-contents__link toc-highlight">6. Security Analysis</a><ul><li><a href="#61-bitvm-style-smart-contract-security" class="table-of-contents__link toc-highlight">6.1 BitVM-Style Smart Contract Security</a></li><li><a href="#62-bitcoin-settlement-security" class="table-of-contents__link toc-highlight">6.2 Bitcoin Settlement Security</a></li><li><a href="#63-censorship-resistance" class="table-of-contents__link toc-highlight">6.3 Censorship Resistance</a></li></ul></li><li><a href="#7-limitations-and-future-directions" class="table-of-contents__link toc-highlight">7. Limitations and Future Directions</a><ul><li><a href="#71-limitations" class="table-of-contents__link toc-highlight">7.1 Limitations</a></li><li><a href="#72-future-directions" class="table-of-contents__link toc-highlight">7.2 Future Directions</a></li></ul></li><li><a href="#conclusions" class="table-of-contents__link toc-highlight">Conclusions</a></li><li><a href="#references" class="table-of-contents__link toc-highlight">References</a></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/Learn/Introduction">Learn</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/Build/GettingStarted/QuickStart">Build</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://t.me/bitlayerofficial" target="_blank" rel="noopener noreferrer" class="footer__link-item">Telegram<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discord.com/invite/GGSjNyD8nj" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://x.com/BitLayerLabs" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://medium.com/@Bitlayer" target="_blank" rel="noopener noreferrer" class="footer__link-item">Blog<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://github.com/bitlayer-org" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Bitlayer</div></div></div></footer></div>
</body>
</html>